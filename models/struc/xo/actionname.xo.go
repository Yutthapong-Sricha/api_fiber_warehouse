package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// ActionName represents a row from 'spc_holding.action_name'.
type ActionName struct {
	IDActionName   int            `json:"id_action_name"`   // id_action_name
	ActorName      sql.NullString `json:"actor_name"`       // actor_name
	ActionName     sql.NullString `json:"action_name"`      // action_name
	IsActiveFlag   sql.NullBool   `json:"is_active_flag"`   // is_active_flag
	RowOrderAction sql.NullInt64  `json:"row_order_action"` // row_order_action
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the ActionName exists in the database.
func (an *ActionName) Exists() bool {
	return an._exists
}

// Deleted returns true when the ActionName has been marked for deletion from
// the database.
func (an *ActionName) Deleted() bool {
	return an._deleted
}

// Insert inserts the ActionName to the database.
func (an *ActionName) Insert(ctx context.Context, db DB) error {
	switch {
	case an._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case an._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO spc_holding.action_name (` +
		`actor_name, action_name, is_active_flag, row_order_action` +
		`) VALUES (` +
		`?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, an.ActorName, an.ActionName, an.IsActiveFlag, an.RowOrderAction)
	res, err := db.ExecContext(ctx, sqlstr, an.ActorName, an.ActionName, an.IsActiveFlag, an.RowOrderAction)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	an.IDActionName = int(id)
	// set exists
	an._exists = true
	return nil
}

// Update updates a ActionName in the database.
func (an *ActionName) Update(ctx context.Context, db DB) error {
	switch {
	case !an._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case an._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE spc_holding.action_name SET ` +
		`actor_name = ?, action_name = ?, is_active_flag = ?, row_order_action = ? ` +
		`WHERE id_action_name = ?`
	// run
	logf(sqlstr, an.ActorName, an.ActionName, an.IsActiveFlag, an.RowOrderAction, an.IDActionName)
	if _, err := db.ExecContext(ctx, sqlstr, an.ActorName, an.ActionName, an.IsActiveFlag, an.RowOrderAction, an.IDActionName); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the ActionName to the database.
func (an *ActionName) Save(ctx context.Context, db DB) error {
	if an.Exists() {
		return an.Update(ctx, db)
	}
	return an.Insert(ctx, db)
}

// Upsert performs an upsert for ActionName.
func (an *ActionName) Upsert(ctx context.Context, db DB) error {
	switch {
	case an._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO spc_holding.action_name (` +
		`id_action_name, actor_name, action_name, is_active_flag, row_order_action` +
		`) VALUES (` +
		`?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`actor_name = VALUES(actor_name), action_name = VALUES(action_name), is_active_flag = VALUES(is_active_flag), row_order_action = VALUES(row_order_action)`
	// run
	logf(sqlstr, an.IDActionName, an.ActorName, an.ActionName, an.IsActiveFlag, an.RowOrderAction)
	if _, err := db.ExecContext(ctx, sqlstr, an.IDActionName, an.ActorName, an.ActionName, an.IsActiveFlag, an.RowOrderAction); err != nil {
		return logerror(err)
	}
	// set exists
	an._exists = true
	return nil
}

// Delete deletes the ActionName from the database.
func (an *ActionName) Delete(ctx context.Context, db DB) error {
	switch {
	case !an._exists: // doesn't exist
		return nil
	case an._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM spc_holding.action_name ` +
		`WHERE id_action_name = ?`
	// run
	logf(sqlstr, an.IDActionName)
	if _, err := db.ExecContext(ctx, sqlstr, an.IDActionName); err != nil {
		return logerror(err)
	}
	// set deleted
	an._deleted = true
	return nil
}

// ActionNameByIDActionName retrieves a row from 'spc_holding.action_name' as a ActionName.
//
// Generated from index 'action_name_id_action_name_pkey'.
func ActionNameByIDActionName(ctx context.Context, db DB, idActionName int) (*ActionName, error) {
	// query
	const sqlstr = `SELECT ` +
		`id_action_name, actor_name, action_name, is_active_flag, row_order_action ` +
		`FROM spc_holding.action_name ` +
		`WHERE id_action_name = ?`
	// run
	logf(sqlstr, idActionName)
	an := ActionName{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idActionName).Scan(&an.IDActionName, &an.ActorName, &an.ActionName, &an.IsActiveFlag, &an.RowOrderAction); err != nil {
		return nil, logerror(err)
	}
	return &an, nil
}
