package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Branch represents a row from 'spc_holding.branch'.
type Branch struct {
	IDBranch           uint           `json:"id_branch"`             // id_branch
	BranchName         sql.NullString `json:"branch_name"`           // branch_name
	Address            sql.NullString `json:"address"`               // address
	IDAddrTambon       sql.NullInt64  `json:"id_addr_tambon"`        // id_addr_tambon
	IDAddrAmphure      sql.NullInt64  `json:"id_addr_amphure"`       // id_addr_amphure
	IDAddrProvince     sql.NullInt64  `json:"id_addr_province"`      // id_addr_province
	BranchTel          sql.NullString `json:"branch_tel"`            // branch_tel
	BranchMobile       sql.NullString `json:"branch_mobile"`         // branch_mobile
	BranchLineID       sql.NullString `json:"branch_line_id"`        // branch_line_id
	IsActiveFlag       sql.NullBool   `json:"is_active_flag"`        // is_active_flag
	RecordUpdateTime   sql.NullInt64  `json:"record_update_time"`    // record_update_time
	RecordUpdateByID   sql.NullInt64  `json:"record_update_by_id"`   // record_update_by_id
	RecordUpdateByName sql.NullString `json:"record_update_by_name"` // record_update_by_name
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Branch exists in the database.
func (b *Branch) Exists() bool {
	return b._exists
}

// Deleted returns true when the Branch has been marked for deletion from
// the database.
func (b *Branch) Deleted() bool {
	return b._deleted
}

// Insert inserts the Branch to the database.
func (b *Branch) Insert(ctx context.Context, db DB) error {
	switch {
	case b._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case b._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO spc_holding.branch (` +
		`branch_name, address, id_addr_tambon, id_addr_amphure, id_addr_province, branch_tel, branch_mobile, branch_line_id, is_active_flag, record_update_time, record_update_by_id, record_update_by_name` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, b.BranchName, b.Address, b.IDAddrTambon, b.IDAddrAmphure, b.IDAddrProvince, b.BranchTel, b.BranchMobile, b.BranchLineID, b.IsActiveFlag, b.RecordUpdateTime, b.RecordUpdateByID, b.RecordUpdateByName)
	res, err := db.ExecContext(ctx, sqlstr, b.BranchName, b.Address, b.IDAddrTambon, b.IDAddrAmphure, b.IDAddrProvince, b.BranchTel, b.BranchMobile, b.BranchLineID, b.IsActiveFlag, b.RecordUpdateTime, b.RecordUpdateByID, b.RecordUpdateByName)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	b.IDBranch = uint(id)
	// set exists
	b._exists = true
	return nil
}

// Update updates a Branch in the database.
func (b *Branch) Update(ctx context.Context, db DB) error {
	switch {
	case !b._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case b._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE spc_holding.branch SET ` +
		`branch_name = ?, address = ?, id_addr_tambon = ?, id_addr_amphure = ?, id_addr_province = ?, branch_tel = ?, branch_mobile = ?, branch_line_id = ?, is_active_flag = ?, record_update_time = ?, record_update_by_id = ?, record_update_by_name = ? ` +
		`WHERE id_branch = ?`
	// run
	logf(sqlstr, b.BranchName, b.Address, b.IDAddrTambon, b.IDAddrAmphure, b.IDAddrProvince, b.BranchTel, b.BranchMobile, b.BranchLineID, b.IsActiveFlag, b.RecordUpdateTime, b.RecordUpdateByID, b.RecordUpdateByName, b.IDBranch)
	if _, err := db.ExecContext(ctx, sqlstr, b.BranchName, b.Address, b.IDAddrTambon, b.IDAddrAmphure, b.IDAddrProvince, b.BranchTel, b.BranchMobile, b.BranchLineID, b.IsActiveFlag, b.RecordUpdateTime, b.RecordUpdateByID, b.RecordUpdateByName, b.IDBranch); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Branch to the database.
func (b *Branch) Save(ctx context.Context, db DB) error {
	if b.Exists() {
		return b.Update(ctx, db)
	}
	return b.Insert(ctx, db)
}

// Upsert performs an upsert for Branch.
func (b *Branch) Upsert(ctx context.Context, db DB) error {
	switch {
	case b._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO spc_holding.branch (` +
		`id_branch, branch_name, address, id_addr_tambon, id_addr_amphure, id_addr_province, branch_tel, branch_mobile, branch_line_id, is_active_flag, record_update_time, record_update_by_id, record_update_by_name` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`branch_name = VALUES(branch_name), address = VALUES(address), id_addr_tambon = VALUES(id_addr_tambon), id_addr_amphure = VALUES(id_addr_amphure), id_addr_province = VALUES(id_addr_province), branch_tel = VALUES(branch_tel), branch_mobile = VALUES(branch_mobile), branch_line_id = VALUES(branch_line_id), is_active_flag = VALUES(is_active_flag), record_update_time = VALUES(record_update_time), record_update_by_id = VALUES(record_update_by_id), record_update_by_name = VALUES(record_update_by_name)`
	// run
	logf(sqlstr, b.IDBranch, b.BranchName, b.Address, b.IDAddrTambon, b.IDAddrAmphure, b.IDAddrProvince, b.BranchTel, b.BranchMobile, b.BranchLineID, b.IsActiveFlag, b.RecordUpdateTime, b.RecordUpdateByID, b.RecordUpdateByName)
	if _, err := db.ExecContext(ctx, sqlstr, b.IDBranch, b.BranchName, b.Address, b.IDAddrTambon, b.IDAddrAmphure, b.IDAddrProvince, b.BranchTel, b.BranchMobile, b.BranchLineID, b.IsActiveFlag, b.RecordUpdateTime, b.RecordUpdateByID, b.RecordUpdateByName); err != nil {
		return logerror(err)
	}
	// set exists
	b._exists = true
	return nil
}

// Delete deletes the Branch from the database.
func (b *Branch) Delete(ctx context.Context, db DB) error {
	switch {
	case !b._exists: // doesn't exist
		return nil
	case b._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM spc_holding.branch ` +
		`WHERE id_branch = ?`
	// run
	logf(sqlstr, b.IDBranch)
	if _, err := db.ExecContext(ctx, sqlstr, b.IDBranch); err != nil {
		return logerror(err)
	}
	// set deleted
	b._deleted = true
	return nil
}

// BranchByIDBranch retrieves a row from 'spc_holding.branch' as a Branch.
//
// Generated from index 'branch_id_branch_pkey'.
func BranchByIDBranch(ctx context.Context, db DB, idBranch uint) (*Branch, error) {
	// query
	const sqlstr = `SELECT ` +
		`id_branch, branch_name, address, id_addr_tambon, id_addr_amphure, id_addr_province, branch_tel, branch_mobile, branch_line_id, is_active_flag, record_update_time, record_update_by_id, record_update_by_name ` +
		`FROM spc_holding.branch ` +
		`WHERE id_branch = ?`
	// run
	logf(sqlstr, idBranch)
	b := Branch{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idBranch).Scan(&b.IDBranch, &b.BranchName, &b.Address, &b.IDAddrTambon, &b.IDAddrAmphure, &b.IDAddrProvince, &b.BranchTel, &b.BranchMobile, &b.BranchLineID, &b.IsActiveFlag, &b.RecordUpdateTime, &b.RecordUpdateByID, &b.RecordUpdateByName); err != nil {
		return nil, logerror(err)
	}
	return &b, nil
}
