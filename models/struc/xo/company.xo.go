package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Company represents a row from 'spc_holding.company'.
type Company struct {
	IDCompany          uint           `json:"id_company"`            // id_company
	CompanyNameTh      sql.NullString `json:"company_name_th"`       // company_name_th
	AddressTh          sql.NullString `json:"address_th"`            // address_th
	CompanyNameEn      sql.NullString `json:"company_name_en"`       // company_name_en
	AddressEn          sql.NullString `json:"address_en"`            // address_en
	IDAddrTambon       sql.NullInt64  `json:"id_addr_tambon"`        // id_addr_tambon
	IDAddrAmphure      sql.NullInt64  `json:"id_addr_amphure"`       // id_addr_amphure
	IDAddrProvince     sql.NullInt64  `json:"id_addr_province"`      // id_addr_province
	TmpZipCode         sql.NullString `json:"tmp_zip_code"`          // tmp_zip_code
	CompanyTel         sql.NullString `json:"company_tel"`           // company_tel
	CompanyEmail       sql.NullString `json:"company_email"`         // company_email
	CompanyMobile      sql.NullString `json:"company_mobile"`        // company_mobile
	RecordCreateTime   sql.NullInt64  `json:"record_create_time"`    // record_create_time
	RecordCreatByID    sql.NullInt64  `json:"record_creat_by_id"`    // record_creat_by_id
	RecordCreatByName  sql.NullString `json:"record_creat_by_name"`  // record_creat_by_name
	RecordUpdateTime   sql.NullInt64  `json:"record_update_time"`    // record_update_time
	RecordUpdateByID   sql.NullInt64  `json:"record_update_by_id"`   // record_update_by_id
	RecordUpdateByName sql.NullString `json:"record_update_by_name"` // record_update_by_name
	TaxID              sql.NullString `json:"tax_id"`                // tax_id
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Company exists in the database.
func (c *Company) Exists() bool {
	return c._exists
}

// Deleted returns true when the Company has been marked for deletion from
// the database.
func (c *Company) Deleted() bool {
	return c._deleted
}

// Insert inserts the Company to the database.
func (c *Company) Insert(ctx context.Context, db DB) error {
	switch {
	case c._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case c._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO spc_holding.company (` +
		`company_name_th, address_th, company_name_en, address_en, id_addr_tambon, id_addr_amphure, id_addr_province, tmp_zip_code, company_tel, company_email, company_mobile, record_create_time, record_creat_by_id, record_creat_by_name, record_update_time, record_update_by_id, record_update_by_name, tax_id` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, c.CompanyNameTh, c.AddressTh, c.CompanyNameEn, c.AddressEn, c.IDAddrTambon, c.IDAddrAmphure, c.IDAddrProvince, c.TmpZipCode, c.CompanyTel, c.CompanyEmail, c.CompanyMobile, c.RecordCreateTime, c.RecordCreatByID, c.RecordCreatByName, c.RecordUpdateTime, c.RecordUpdateByID, c.RecordUpdateByName, c.TaxID)
	res, err := db.ExecContext(ctx, sqlstr, c.CompanyNameTh, c.AddressTh, c.CompanyNameEn, c.AddressEn, c.IDAddrTambon, c.IDAddrAmphure, c.IDAddrProvince, c.TmpZipCode, c.CompanyTel, c.CompanyEmail, c.CompanyMobile, c.RecordCreateTime, c.RecordCreatByID, c.RecordCreatByName, c.RecordUpdateTime, c.RecordUpdateByID, c.RecordUpdateByName, c.TaxID)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	c.IDCompany = uint(id)
	// set exists
	c._exists = true
	return nil
}

// Update updates a Company in the database.
func (c *Company) Update(ctx context.Context, db DB) error {
	switch {
	case !c._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case c._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE spc_holding.company SET ` +
		`company_name_th = ?, address_th = ?, company_name_en = ?, address_en = ?, id_addr_tambon = ?, id_addr_amphure = ?, id_addr_province = ?, tmp_zip_code = ?, company_tel = ?, company_email = ?, company_mobile = ?, record_create_time = ?, record_creat_by_id = ?, record_creat_by_name = ?, record_update_time = ?, record_update_by_id = ?, record_update_by_name = ?, tax_id = ? ` +
		`WHERE id_company = ?`
	// run
	logf(sqlstr, c.CompanyNameTh, c.AddressTh, c.CompanyNameEn, c.AddressEn, c.IDAddrTambon, c.IDAddrAmphure, c.IDAddrProvince, c.TmpZipCode, c.CompanyTel, c.CompanyEmail, c.CompanyMobile, c.RecordCreateTime, c.RecordCreatByID, c.RecordCreatByName, c.RecordUpdateTime, c.RecordUpdateByID, c.RecordUpdateByName, c.TaxID, c.IDCompany)
	if _, err := db.ExecContext(ctx, sqlstr, c.CompanyNameTh, c.AddressTh, c.CompanyNameEn, c.AddressEn, c.IDAddrTambon, c.IDAddrAmphure, c.IDAddrProvince, c.TmpZipCode, c.CompanyTel, c.CompanyEmail, c.CompanyMobile, c.RecordCreateTime, c.RecordCreatByID, c.RecordCreatByName, c.RecordUpdateTime, c.RecordUpdateByID, c.RecordUpdateByName, c.TaxID, c.IDCompany); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Company to the database.
func (c *Company) Save(ctx context.Context, db DB) error {
	if c.Exists() {
		return c.Update(ctx, db)
	}
	return c.Insert(ctx, db)
}

// Upsert performs an upsert for Company.
func (c *Company) Upsert(ctx context.Context, db DB) error {
	switch {
	case c._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO spc_holding.company (` +
		`id_company, company_name_th, address_th, company_name_en, address_en, id_addr_tambon, id_addr_amphure, id_addr_province, tmp_zip_code, company_tel, company_email, company_mobile, record_create_time, record_creat_by_id, record_creat_by_name, record_update_time, record_update_by_id, record_update_by_name, tax_id` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`company_name_th = VALUES(company_name_th), address_th = VALUES(address_th), company_name_en = VALUES(company_name_en), address_en = VALUES(address_en), id_addr_tambon = VALUES(id_addr_tambon), id_addr_amphure = VALUES(id_addr_amphure), id_addr_province = VALUES(id_addr_province), tmp_zip_code = VALUES(tmp_zip_code), company_tel = VALUES(company_tel), company_email = VALUES(company_email), company_mobile = VALUES(company_mobile), record_create_time = VALUES(record_create_time), record_creat_by_id = VALUES(record_creat_by_id), record_creat_by_name = VALUES(record_creat_by_name), record_update_time = VALUES(record_update_time), record_update_by_id = VALUES(record_update_by_id), record_update_by_name = VALUES(record_update_by_name), tax_id = VALUES(tax_id)`
	// run
	logf(sqlstr, c.IDCompany, c.CompanyNameTh, c.AddressTh, c.CompanyNameEn, c.AddressEn, c.IDAddrTambon, c.IDAddrAmphure, c.IDAddrProvince, c.TmpZipCode, c.CompanyTel, c.CompanyEmail, c.CompanyMobile, c.RecordCreateTime, c.RecordCreatByID, c.RecordCreatByName, c.RecordUpdateTime, c.RecordUpdateByID, c.RecordUpdateByName, c.TaxID)
	if _, err := db.ExecContext(ctx, sqlstr, c.IDCompany, c.CompanyNameTh, c.AddressTh, c.CompanyNameEn, c.AddressEn, c.IDAddrTambon, c.IDAddrAmphure, c.IDAddrProvince, c.TmpZipCode, c.CompanyTel, c.CompanyEmail, c.CompanyMobile, c.RecordCreateTime, c.RecordCreatByID, c.RecordCreatByName, c.RecordUpdateTime, c.RecordUpdateByID, c.RecordUpdateByName, c.TaxID); err != nil {
		return logerror(err)
	}
	// set exists
	c._exists = true
	return nil
}

// Delete deletes the Company from the database.
func (c *Company) Delete(ctx context.Context, db DB) error {
	switch {
	case !c._exists: // doesn't exist
		return nil
	case c._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM spc_holding.company ` +
		`WHERE id_company = ?`
	// run
	logf(sqlstr, c.IDCompany)
	if _, err := db.ExecContext(ctx, sqlstr, c.IDCompany); err != nil {
		return logerror(err)
	}
	// set deleted
	c._deleted = true
	return nil
}

// CompanyByIDCompany retrieves a row from 'spc_holding.company' as a Company.
//
// Generated from index 'company_id_company_pkey'.
func CompanyByIDCompany(ctx context.Context, db DB, idCompany uint) (*Company, error) {
	// query
	const sqlstr = `SELECT ` +
		`id_company, company_name_th, address_th, company_name_en, address_en, id_addr_tambon, id_addr_amphure, id_addr_province, tmp_zip_code, company_tel, company_email, company_mobile, record_create_time, record_creat_by_id, record_creat_by_name, record_update_time, record_update_by_id, record_update_by_name, tax_id ` +
		`FROM spc_holding.company ` +
		`WHERE id_company = ?`
	// run
	logf(sqlstr, idCompany)
	c := Company{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idCompany).Scan(&c.IDCompany, &c.CompanyNameTh, &c.AddressTh, &c.CompanyNameEn, &c.AddressEn, &c.IDAddrTambon, &c.IDAddrAmphure, &c.IDAddrProvince, &c.TmpZipCode, &c.CompanyTel, &c.CompanyEmail, &c.CompanyMobile, &c.RecordCreateTime, &c.RecordCreatByID, &c.RecordCreatByName, &c.RecordUpdateTime, &c.RecordUpdateByID, &c.RecordUpdateByName, &c.TaxID); err != nil {
		return nil, logerror(err)
	}
	return &c, nil
}
