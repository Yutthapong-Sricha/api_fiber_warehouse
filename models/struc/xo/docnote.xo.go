package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// DocNote represents a row from 'spc_holding.doc_note'.
type DocNote struct {
	IDDocNote          uint           `json:"id_doc_note"`           // id_doc_note
	IDDocCore          sql.NullInt64  `json:"id_doc_core"`           // id_doc_core
	ShowCust2Int4      sql.NullBool   `json:"show_cust2_int4"`       // show_cust2_int4
	InputDateDdmm20yy  sql.NullString `json:"input_date_ddmm20yy"`   // input_date_ddmm20yy
	DateInt            sql.NullInt64  `json:"date_int"`              // date_int
	Note               sql.NullString `json:"note"`                  // note
	RecordCreateTime   sql.NullInt64  `json:"record_create_time"`    // record_create_time
	RecordCreateByID   sql.NullInt64  `json:"record_create_by_id"`   // record_create_by_id
	RecordCreateByName sql.NullString `json:"record_create_by_name"` // record_create_by_name
	RecordUpdateTime   sql.NullInt64  `json:"record_update_time"`    // record_update_time
	RecordUpdateByID   sql.NullInt64  `json:"record_update_by_id"`   // record_update_by_id
	RecordUpdateByName sql.NullString `json:"record_update_by_name"` // record_update_by_name
	IsActiveFlag       sql.NullBool   `json:"is_active_flag"`        // is_active_flag
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the DocNote exists in the database.
func (dn *DocNote) Exists() bool {
	return dn._exists
}

// Deleted returns true when the DocNote has been marked for deletion from
// the database.
func (dn *DocNote) Deleted() bool {
	return dn._deleted
}

// Insert inserts the DocNote to the database.
func (dn *DocNote) Insert(ctx context.Context, db DB) error {
	switch {
	case dn._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case dn._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO spc_holding.doc_note (` +
		`id_doc_core, show_cust2_int4, input_date_ddmm20yy, date_int, note, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, is_active_flag` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, dn.IDDocCore, dn.ShowCust2Int4, dn.InputDateDdmm20yy, dn.DateInt, dn.Note, dn.RecordCreateTime, dn.RecordCreateByID, dn.RecordCreateByName, dn.RecordUpdateTime, dn.RecordUpdateByID, dn.RecordUpdateByName, dn.IsActiveFlag)
	res, err := db.ExecContext(ctx, sqlstr, dn.IDDocCore, dn.ShowCust2Int4, dn.InputDateDdmm20yy, dn.DateInt, dn.Note, dn.RecordCreateTime, dn.RecordCreateByID, dn.RecordCreateByName, dn.RecordUpdateTime, dn.RecordUpdateByID, dn.RecordUpdateByName, dn.IsActiveFlag)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	dn.IDDocNote = uint(id)
	// set exists
	dn._exists = true
	return nil
}

// Update updates a DocNote in the database.
func (dn *DocNote) Update(ctx context.Context, db DB) error {
	switch {
	case !dn._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case dn._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE spc_holding.doc_note SET ` +
		`id_doc_core = ?, show_cust2_int4 = ?, input_date_ddmm20yy = ?, date_int = ?, note = ?, record_create_time = ?, record_create_by_id = ?, record_create_by_name = ?, record_update_time = ?, record_update_by_id = ?, record_update_by_name = ?, is_active_flag = ? ` +
		`WHERE id_doc_note = ?`
	// run
	logf(sqlstr, dn.IDDocCore, dn.ShowCust2Int4, dn.InputDateDdmm20yy, dn.DateInt, dn.Note, dn.RecordCreateTime, dn.RecordCreateByID, dn.RecordCreateByName, dn.RecordUpdateTime, dn.RecordUpdateByID, dn.RecordUpdateByName, dn.IsActiveFlag, dn.IDDocNote)
	if _, err := db.ExecContext(ctx, sqlstr, dn.IDDocCore, dn.ShowCust2Int4, dn.InputDateDdmm20yy, dn.DateInt, dn.Note, dn.RecordCreateTime, dn.RecordCreateByID, dn.RecordCreateByName, dn.RecordUpdateTime, dn.RecordUpdateByID, dn.RecordUpdateByName, dn.IsActiveFlag, dn.IDDocNote); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the DocNote to the database.
func (dn *DocNote) Save(ctx context.Context, db DB) error {
	if dn.Exists() {
		return dn.Update(ctx, db)
	}
	return dn.Insert(ctx, db)
}

// Upsert performs an upsert for DocNote.
func (dn *DocNote) Upsert(ctx context.Context, db DB) error {
	switch {
	case dn._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO spc_holding.doc_note (` +
		`id_doc_note, id_doc_core, show_cust2_int4, input_date_ddmm20yy, date_int, note, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, is_active_flag` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`id_doc_core = VALUES(id_doc_core), show_cust2_int4 = VALUES(show_cust2_int4), input_date_ddmm20yy = VALUES(input_date_ddmm20yy), date_int = VALUES(date_int), note = VALUES(note), record_create_time = VALUES(record_create_time), record_create_by_id = VALUES(record_create_by_id), record_create_by_name = VALUES(record_create_by_name), record_update_time = VALUES(record_update_time), record_update_by_id = VALUES(record_update_by_id), record_update_by_name = VALUES(record_update_by_name), is_active_flag = VALUES(is_active_flag)`
	// run
	logf(sqlstr, dn.IDDocNote, dn.IDDocCore, dn.ShowCust2Int4, dn.InputDateDdmm20yy, dn.DateInt, dn.Note, dn.RecordCreateTime, dn.RecordCreateByID, dn.RecordCreateByName, dn.RecordUpdateTime, dn.RecordUpdateByID, dn.RecordUpdateByName, dn.IsActiveFlag)
	if _, err := db.ExecContext(ctx, sqlstr, dn.IDDocNote, dn.IDDocCore, dn.ShowCust2Int4, dn.InputDateDdmm20yy, dn.DateInt, dn.Note, dn.RecordCreateTime, dn.RecordCreateByID, dn.RecordCreateByName, dn.RecordUpdateTime, dn.RecordUpdateByID, dn.RecordUpdateByName, dn.IsActiveFlag); err != nil {
		return logerror(err)
	}
	// set exists
	dn._exists = true
	return nil
}

// Delete deletes the DocNote from the database.
func (dn *DocNote) Delete(ctx context.Context, db DB) error {
	switch {
	case !dn._exists: // doesn't exist
		return nil
	case dn._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM spc_holding.doc_note ` +
		`WHERE id_doc_note = ?`
	// run
	logf(sqlstr, dn.IDDocNote)
	if _, err := db.ExecContext(ctx, sqlstr, dn.IDDocNote); err != nil {
		return logerror(err)
	}
	// set deleted
	dn._deleted = true
	return nil
}

// DocNoteByIDDocNote retrieves a row from 'spc_holding.doc_note' as a DocNote.
//
// Generated from index 'doc_note_id_doc_note_pkey'.
func DocNoteByIDDocNote(ctx context.Context, db DB, idDocNote uint) (*DocNote, error) {
	// query
	const sqlstr = `SELECT ` +
		`id_doc_note, id_doc_core, show_cust2_int4, input_date_ddmm20yy, date_int, note, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, is_active_flag ` +
		`FROM spc_holding.doc_note ` +
		`WHERE id_doc_note = ?`
	// run
	logf(sqlstr, idDocNote)
	dn := DocNote{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idDocNote).Scan(&dn.IDDocNote, &dn.IDDocCore, &dn.ShowCust2Int4, &dn.InputDateDdmm20yy, &dn.DateInt, &dn.Note, &dn.RecordCreateTime, &dn.RecordCreateByID, &dn.RecordCreateByName, &dn.RecordUpdateTime, &dn.RecordUpdateByID, &dn.RecordUpdateByName, &dn.IsActiveFlag); err != nil {
		return nil, logerror(err)
	}
	return &dn, nil
}
