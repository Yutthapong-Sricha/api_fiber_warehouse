package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// DocType represents a row from 'spc_holding.doc_type'.
type DocType struct {
	IDDocType        uint           `json:"id_doc_type"`         // id_doc_type
	DocName          sql.NullString `json:"doc_name"`            // doc_name
	GroupType1in2out sql.NullBool   `json:"group_type_1in_2out"` // group_type_1in_2out
	PrefixDocNumber  sql.NullString `json:"prefix_doc_number"`   // prefix_doc_number
	DocDetail        sql.NullString `json:"doc_detail"`          // doc_detail
	IsActiveFlag     sql.NullBool   `json:"is_active_flag"`      // is_active_flag
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the DocType exists in the database.
func (dt *DocType) Exists() bool {
	return dt._exists
}

// Deleted returns true when the DocType has been marked for deletion from
// the database.
func (dt *DocType) Deleted() bool {
	return dt._deleted
}

// Insert inserts the DocType to the database.
func (dt *DocType) Insert(ctx context.Context, db DB) error {
	switch {
	case dt._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case dt._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO spc_holding.doc_type (` +
		`doc_name, group_type_1in_2out, prefix_doc_number, doc_detail, is_active_flag` +
		`) VALUES (` +
		`?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, dt.DocName, dt.GroupType1in2out, dt.PrefixDocNumber, dt.DocDetail, dt.IsActiveFlag)
	res, err := db.ExecContext(ctx, sqlstr, dt.DocName, dt.GroupType1in2out, dt.PrefixDocNumber, dt.DocDetail, dt.IsActiveFlag)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	dt.IDDocType = uint(id)
	// set exists
	dt._exists = true
	return nil
}

// Update updates a DocType in the database.
func (dt *DocType) Update(ctx context.Context, db DB) error {
	switch {
	case !dt._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case dt._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE spc_holding.doc_type SET ` +
		`doc_name = ?, group_type_1in_2out = ?, prefix_doc_number = ?, doc_detail = ?, is_active_flag = ? ` +
		`WHERE id_doc_type = ?`
	// run
	logf(sqlstr, dt.DocName, dt.GroupType1in2out, dt.PrefixDocNumber, dt.DocDetail, dt.IsActiveFlag, dt.IDDocType)
	if _, err := db.ExecContext(ctx, sqlstr, dt.DocName, dt.GroupType1in2out, dt.PrefixDocNumber, dt.DocDetail, dt.IsActiveFlag, dt.IDDocType); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the DocType to the database.
func (dt *DocType) Save(ctx context.Context, db DB) error {
	if dt.Exists() {
		return dt.Update(ctx, db)
	}
	return dt.Insert(ctx, db)
}

// Upsert performs an upsert for DocType.
func (dt *DocType) Upsert(ctx context.Context, db DB) error {
	switch {
	case dt._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO spc_holding.doc_type (` +
		`id_doc_type, doc_name, group_type_1in_2out, prefix_doc_number, doc_detail, is_active_flag` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`doc_name = VALUES(doc_name), group_type_1in_2out = VALUES(group_type_1in_2out), prefix_doc_number = VALUES(prefix_doc_number), doc_detail = VALUES(doc_detail), is_active_flag = VALUES(is_active_flag)`
	// run
	logf(sqlstr, dt.IDDocType, dt.DocName, dt.GroupType1in2out, dt.PrefixDocNumber, dt.DocDetail, dt.IsActiveFlag)
	if _, err := db.ExecContext(ctx, sqlstr, dt.IDDocType, dt.DocName, dt.GroupType1in2out, dt.PrefixDocNumber, dt.DocDetail, dt.IsActiveFlag); err != nil {
		return logerror(err)
	}
	// set exists
	dt._exists = true
	return nil
}

// Delete deletes the DocType from the database.
func (dt *DocType) Delete(ctx context.Context, db DB) error {
	switch {
	case !dt._exists: // doesn't exist
		return nil
	case dt._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM spc_holding.doc_type ` +
		`WHERE id_doc_type = ?`
	// run
	logf(sqlstr, dt.IDDocType)
	if _, err := db.ExecContext(ctx, sqlstr, dt.IDDocType); err != nil {
		return logerror(err)
	}
	// set deleted
	dt._deleted = true
	return nil
}

// DocTypeByIDDocType retrieves a row from 'spc_holding.doc_type' as a DocType.
//
// Generated from index 'doc_type_id_doc_type_pkey'.
func DocTypeByIDDocType(ctx context.Context, db DB, idDocType uint) (*DocType, error) {
	// query
	const sqlstr = `SELECT ` +
		`id_doc_type, doc_name, group_type_1in_2out, prefix_doc_number, doc_detail, is_active_flag ` +
		`FROM spc_holding.doc_type ` +
		`WHERE id_doc_type = ?`
	// run
	logf(sqlstr, idDocType)
	dt := DocType{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idDocType).Scan(&dt.IDDocType, &dt.DocName, &dt.GroupType1in2out, &dt.PrefixDocNumber, &dt.DocDetail, &dt.IsActiveFlag); err != nil {
		return nil, logerror(err)
	}
	return &dt, nil
}
