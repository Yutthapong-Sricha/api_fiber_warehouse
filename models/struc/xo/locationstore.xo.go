package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// LocationStore represents a row from 'spc_holding.location_store'.
type LocationStore struct {
	IDLocaStore        uint           `json:"id_loca_store"`         // id_loca_store
	LocaStoreName      sql.NullString `json:"loca_store_name"`       // loca_store_name
	Note               sql.NullString `json:"note"`                  // note
	Show356Flag        sql.NullBool   `json:"show_356_flag"`         // show_356_flag
	Store356Flag       sql.NullBool   `json:"store_356_flag"`        // store_356_flag
	RecordCreateTime   sql.NullInt64  `json:"record_create_time"`    // record_create_time
	RecordCreateByID   sql.NullInt64  `json:"record_create_by_id"`   // record_create_by_id
	RecordCreateByName sql.NullString `json:"record_create_by_name"` // record_create_by_name
	RecordUpdateTime   sql.NullInt64  `json:"record_update_time"`    // record_update_time
	RecordUpdateByID   sql.NullInt64  `json:"record_update_by_id"`   // record_update_by_id
	RecordUpdateByName sql.NullString `json:"record_update_by_name"` // record_update_by_name
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the LocationStore exists in the database.
func (ls *LocationStore) Exists() bool {
	return ls._exists
}

// Deleted returns true when the LocationStore has been marked for deletion from
// the database.
func (ls *LocationStore) Deleted() bool {
	return ls._deleted
}

// Insert inserts the LocationStore to the database.
func (ls *LocationStore) Insert(ctx context.Context, db DB) error {
	switch {
	case ls._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ls._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO spc_holding.location_store (` +
		`loca_store_name, note, show_356_flag, store_356_flag, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, ls.LocaStoreName, ls.Note, ls.Show356Flag, ls.Store356Flag, ls.RecordCreateTime, ls.RecordCreateByID, ls.RecordCreateByName, ls.RecordUpdateTime, ls.RecordUpdateByID, ls.RecordUpdateByName)
	res, err := db.ExecContext(ctx, sqlstr, ls.LocaStoreName, ls.Note, ls.Show356Flag, ls.Store356Flag, ls.RecordCreateTime, ls.RecordCreateByID, ls.RecordCreateByName, ls.RecordUpdateTime, ls.RecordUpdateByID, ls.RecordUpdateByName)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	ls.IDLocaStore = uint(id)
	// set exists
	ls._exists = true
	return nil
}

// Update updates a LocationStore in the database.
func (ls *LocationStore) Update(ctx context.Context, db DB) error {
	switch {
	case !ls._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ls._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE spc_holding.location_store SET ` +
		`loca_store_name = ?, note = ?, show_356_flag = ?, store_356_flag = ?, record_create_time = ?, record_create_by_id = ?, record_create_by_name = ?, record_update_time = ?, record_update_by_id = ?, record_update_by_name = ? ` +
		`WHERE id_loca_store = ?`
	// run
	logf(sqlstr, ls.LocaStoreName, ls.Note, ls.Show356Flag, ls.Store356Flag, ls.RecordCreateTime, ls.RecordCreateByID, ls.RecordCreateByName, ls.RecordUpdateTime, ls.RecordUpdateByID, ls.RecordUpdateByName, ls.IDLocaStore)
	if _, err := db.ExecContext(ctx, sqlstr, ls.LocaStoreName, ls.Note, ls.Show356Flag, ls.Store356Flag, ls.RecordCreateTime, ls.RecordCreateByID, ls.RecordCreateByName, ls.RecordUpdateTime, ls.RecordUpdateByID, ls.RecordUpdateByName, ls.IDLocaStore); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the LocationStore to the database.
func (ls *LocationStore) Save(ctx context.Context, db DB) error {
	if ls.Exists() {
		return ls.Update(ctx, db)
	}
	return ls.Insert(ctx, db)
}

// Upsert performs an upsert for LocationStore.
func (ls *LocationStore) Upsert(ctx context.Context, db DB) error {
	switch {
	case ls._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO spc_holding.location_store (` +
		`id_loca_store, loca_store_name, note, show_356_flag, store_356_flag, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`loca_store_name = VALUES(loca_store_name), note = VALUES(note), show_356_flag = VALUES(show_356_flag), store_356_flag = VALUES(store_356_flag), record_create_time = VALUES(record_create_time), record_create_by_id = VALUES(record_create_by_id), record_create_by_name = VALUES(record_create_by_name), record_update_time = VALUES(record_update_time), record_update_by_id = VALUES(record_update_by_id), record_update_by_name = VALUES(record_update_by_name)`
	// run
	logf(sqlstr, ls.IDLocaStore, ls.LocaStoreName, ls.Note, ls.Show356Flag, ls.Store356Flag, ls.RecordCreateTime, ls.RecordCreateByID, ls.RecordCreateByName, ls.RecordUpdateTime, ls.RecordUpdateByID, ls.RecordUpdateByName)
	if _, err := db.ExecContext(ctx, sqlstr, ls.IDLocaStore, ls.LocaStoreName, ls.Note, ls.Show356Flag, ls.Store356Flag, ls.RecordCreateTime, ls.RecordCreateByID, ls.RecordCreateByName, ls.RecordUpdateTime, ls.RecordUpdateByID, ls.RecordUpdateByName); err != nil {
		return logerror(err)
	}
	// set exists
	ls._exists = true
	return nil
}

// Delete deletes the LocationStore from the database.
func (ls *LocationStore) Delete(ctx context.Context, db DB) error {
	switch {
	case !ls._exists: // doesn't exist
		return nil
	case ls._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM spc_holding.location_store ` +
		`WHERE id_loca_store = ?`
	// run
	logf(sqlstr, ls.IDLocaStore)
	if _, err := db.ExecContext(ctx, sqlstr, ls.IDLocaStore); err != nil {
		return logerror(err)
	}
	// set deleted
	ls._deleted = true
	return nil
}

// LocationStoreByIDLocaStore retrieves a row from 'spc_holding.location_store' as a LocationStore.
//
// Generated from index 'location_store_id_loca_store_pkey'.
func LocationStoreByIDLocaStore(ctx context.Context, db DB, idLocaStore uint) (*LocationStore, error) {
	// query
	const sqlstr = `SELECT ` +
		`id_loca_store, loca_store_name, note, show_356_flag, store_356_flag, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name ` +
		`FROM spc_holding.location_store ` +
		`WHERE id_loca_store = ?`
	// run
	logf(sqlstr, idLocaStore)
	ls := LocationStore{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idLocaStore).Scan(&ls.IDLocaStore, &ls.LocaStoreName, &ls.Note, &ls.Show356Flag, &ls.Store356Flag, &ls.RecordCreateTime, &ls.RecordCreateByID, &ls.RecordCreateByName, &ls.RecordUpdateTime, &ls.RecordUpdateByID, &ls.RecordUpdateByName); err != nil {
		return nil, logerror(err)
	}
	return &ls, nil
}
