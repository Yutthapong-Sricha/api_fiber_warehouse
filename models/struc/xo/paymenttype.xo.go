package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// PaymentType represents a row from 'spc_holding.payment_type'.
type PaymentType struct {
	IDPaymentType   uint           `json:"id_payment_type"`    // id_payment_type
	PayTypeName     sql.NullString `json:"pay_type_name"`      // pay_type_name
	PayType356Flag  sql.NullBool   `json:"pay_type_356_flag"`  // pay_type_356_flag
	IDDocType       sql.NullInt64  `json:"id_doc_type"`        // id_doc_type
	ShowType356Flag sql.NullBool   `json:"show_type_356_flag"` // show_type_356_flag
	RowOrderType    sql.NullInt64  `json:"row_order_type"`     // row_order_type
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the PaymentType exists in the database.
func (pt *PaymentType) Exists() bool {
	return pt._exists
}

// Deleted returns true when the PaymentType has been marked for deletion from
// the database.
func (pt *PaymentType) Deleted() bool {
	return pt._deleted
}

// Insert inserts the PaymentType to the database.
func (pt *PaymentType) Insert(ctx context.Context, db DB) error {
	switch {
	case pt._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case pt._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO spc_holding.payment_type (` +
		`pay_type_name, pay_type_356_flag, id_doc_type, show_type_356_flag, row_order_type` +
		`) VALUES (` +
		`?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, pt.PayTypeName, pt.PayType356Flag, pt.IDDocType, pt.ShowType356Flag, pt.RowOrderType)
	res, err := db.ExecContext(ctx, sqlstr, pt.PayTypeName, pt.PayType356Flag, pt.IDDocType, pt.ShowType356Flag, pt.RowOrderType)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	pt.IDPaymentType = uint(id)
	// set exists
	pt._exists = true
	return nil
}

// Update updates a PaymentType in the database.
func (pt *PaymentType) Update(ctx context.Context, db DB) error {
	switch {
	case !pt._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case pt._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE spc_holding.payment_type SET ` +
		`pay_type_name = ?, pay_type_356_flag = ?, id_doc_type = ?, show_type_356_flag = ?, row_order_type = ? ` +
		`WHERE id_payment_type = ?`
	// run
	logf(sqlstr, pt.PayTypeName, pt.PayType356Flag, pt.IDDocType, pt.ShowType356Flag, pt.RowOrderType, pt.IDPaymentType)
	if _, err := db.ExecContext(ctx, sqlstr, pt.PayTypeName, pt.PayType356Flag, pt.IDDocType, pt.ShowType356Flag, pt.RowOrderType, pt.IDPaymentType); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the PaymentType to the database.
func (pt *PaymentType) Save(ctx context.Context, db DB) error {
	if pt.Exists() {
		return pt.Update(ctx, db)
	}
	return pt.Insert(ctx, db)
}

// Upsert performs an upsert for PaymentType.
func (pt *PaymentType) Upsert(ctx context.Context, db DB) error {
	switch {
	case pt._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO spc_holding.payment_type (` +
		`id_payment_type, pay_type_name, pay_type_356_flag, id_doc_type, show_type_356_flag, row_order_type` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`pay_type_name = VALUES(pay_type_name), pay_type_356_flag = VALUES(pay_type_356_flag), id_doc_type = VALUES(id_doc_type), show_type_356_flag = VALUES(show_type_356_flag), row_order_type = VALUES(row_order_type)`
	// run
	logf(sqlstr, pt.IDPaymentType, pt.PayTypeName, pt.PayType356Flag, pt.IDDocType, pt.ShowType356Flag, pt.RowOrderType)
	if _, err := db.ExecContext(ctx, sqlstr, pt.IDPaymentType, pt.PayTypeName, pt.PayType356Flag, pt.IDDocType, pt.ShowType356Flag, pt.RowOrderType); err != nil {
		return logerror(err)
	}
	// set exists
	pt._exists = true
	return nil
}

// Delete deletes the PaymentType from the database.
func (pt *PaymentType) Delete(ctx context.Context, db DB) error {
	switch {
	case !pt._exists: // doesn't exist
		return nil
	case pt._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM spc_holding.payment_type ` +
		`WHERE id_payment_type = ?`
	// run
	logf(sqlstr, pt.IDPaymentType)
	if _, err := db.ExecContext(ctx, sqlstr, pt.IDPaymentType); err != nil {
		return logerror(err)
	}
	// set deleted
	pt._deleted = true
	return nil
}

// PaymentTypeByIDPaymentType retrieves a row from 'spc_holding.payment_type' as a PaymentType.
//
// Generated from index 'payment_type_id_payment_type_pkey'.
func PaymentTypeByIDPaymentType(ctx context.Context, db DB, idPaymentType uint) (*PaymentType, error) {
	// query
	const sqlstr = `SELECT ` +
		`id_payment_type, pay_type_name, pay_type_356_flag, id_doc_type, show_type_356_flag, row_order_type ` +
		`FROM spc_holding.payment_type ` +
		`WHERE id_payment_type = ?`
	// run
	logf(sqlstr, idPaymentType)
	pt := PaymentType{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idPaymentType).Scan(&pt.IDPaymentType, &pt.PayTypeName, &pt.PayType356Flag, &pt.IDDocType, &pt.ShowType356Flag, &pt.RowOrderType); err != nil {
		return nil, logerror(err)
	}
	return &pt, nil
}
