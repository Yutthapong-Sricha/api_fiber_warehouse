package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// ProdCategory represents a row from 'spc_holding.prod_category'.
type ProdCategory struct {
	IDProdCategory     uint           `json:"id_prod_category"`      // id_prod_category
	CategoryName       sql.NullString `json:"category_name"`         // category_name
	IsActiveFlag       sql.NullBool   `json:"is_active_flag"`        // is_active_flag
	RecordCreateTime   sql.NullInt64  `json:"record_create_time"`    // record_create_time
	RecordCreateByID   sql.NullInt64  `json:"record_create_by_id"`   // record_create_by_id
	RecordCreateByName sql.NullString `json:"record_create_by_name"` // record_create_by_name
	RecordUpdateTime   sql.NullInt64  `json:"record_update_time"`    // record_update_time
	RecordUpdateByID   sql.NullInt64  `json:"record_update_by_id"`   // record_update_by_id
	RecordUpdateByName sql.NullString `json:"record_update_by_name"` // record_update_by_name
	CategoryIDOld      sql.NullInt64  `json:"CategoryId_old"`        // CategoryId_old
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the ProdCategory exists in the database.
func (pc *ProdCategory) Exists() bool {
	return pc._exists
}

// Deleted returns true when the ProdCategory has been marked for deletion from
// the database.
func (pc *ProdCategory) Deleted() bool {
	return pc._deleted
}

// Insert inserts the ProdCategory to the database.
func (pc *ProdCategory) Insert(ctx context.Context, db DB) error {
	switch {
	case pc._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case pc._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO spc_holding.prod_category (` +
		`category_name, is_active_flag, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, CategoryId_old` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, pc.CategoryName, pc.IsActiveFlag, pc.RecordCreateTime, pc.RecordCreateByID, pc.RecordCreateByName, pc.RecordUpdateTime, pc.RecordUpdateByID, pc.RecordUpdateByName, pc.CategoryIDOld)
	res, err := db.ExecContext(ctx, sqlstr, pc.CategoryName, pc.IsActiveFlag, pc.RecordCreateTime, pc.RecordCreateByID, pc.RecordCreateByName, pc.RecordUpdateTime, pc.RecordUpdateByID, pc.RecordUpdateByName, pc.CategoryIDOld)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	pc.IDProdCategory = uint(id)
	// set exists
	pc._exists = true
	return nil
}

// Update updates a ProdCategory in the database.
func (pc *ProdCategory) Update(ctx context.Context, db DB) error {
	switch {
	case !pc._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case pc._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE spc_holding.prod_category SET ` +
		`category_name = ?, is_active_flag = ?, record_create_time = ?, record_create_by_id = ?, record_create_by_name = ?, record_update_time = ?, record_update_by_id = ?, record_update_by_name = ?, CategoryId_old = ? ` +
		`WHERE id_prod_category = ?`
	// run
	logf(sqlstr, pc.CategoryName, pc.IsActiveFlag, pc.RecordCreateTime, pc.RecordCreateByID, pc.RecordCreateByName, pc.RecordUpdateTime, pc.RecordUpdateByID, pc.RecordUpdateByName, pc.CategoryIDOld, pc.IDProdCategory)
	if _, err := db.ExecContext(ctx, sqlstr, pc.CategoryName, pc.IsActiveFlag, pc.RecordCreateTime, pc.RecordCreateByID, pc.RecordCreateByName, pc.RecordUpdateTime, pc.RecordUpdateByID, pc.RecordUpdateByName, pc.CategoryIDOld, pc.IDProdCategory); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the ProdCategory to the database.
func (pc *ProdCategory) Save(ctx context.Context, db DB) error {
	if pc.Exists() {
		return pc.Update(ctx, db)
	}
	return pc.Insert(ctx, db)
}

// Upsert performs an upsert for ProdCategory.
func (pc *ProdCategory) Upsert(ctx context.Context, db DB) error {
	switch {
	case pc._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO spc_holding.prod_category (` +
		`id_prod_category, category_name, is_active_flag, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, CategoryId_old` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`category_name = VALUES(category_name), is_active_flag = VALUES(is_active_flag), record_create_time = VALUES(record_create_time), record_create_by_id = VALUES(record_create_by_id), record_create_by_name = VALUES(record_create_by_name), record_update_time = VALUES(record_update_time), record_update_by_id = VALUES(record_update_by_id), record_update_by_name = VALUES(record_update_by_name), CategoryId_old = VALUES(CategoryId_old)`
	// run
	logf(sqlstr, pc.IDProdCategory, pc.CategoryName, pc.IsActiveFlag, pc.RecordCreateTime, pc.RecordCreateByID, pc.RecordCreateByName, pc.RecordUpdateTime, pc.RecordUpdateByID, pc.RecordUpdateByName, pc.CategoryIDOld)
	if _, err := db.ExecContext(ctx, sqlstr, pc.IDProdCategory, pc.CategoryName, pc.IsActiveFlag, pc.RecordCreateTime, pc.RecordCreateByID, pc.RecordCreateByName, pc.RecordUpdateTime, pc.RecordUpdateByID, pc.RecordUpdateByName, pc.CategoryIDOld); err != nil {
		return logerror(err)
	}
	// set exists
	pc._exists = true
	return nil
}

// Delete deletes the ProdCategory from the database.
func (pc *ProdCategory) Delete(ctx context.Context, db DB) error {
	switch {
	case !pc._exists: // doesn't exist
		return nil
	case pc._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM spc_holding.prod_category ` +
		`WHERE id_prod_category = ?`
	// run
	logf(sqlstr, pc.IDProdCategory)
	if _, err := db.ExecContext(ctx, sqlstr, pc.IDProdCategory); err != nil {
		return logerror(err)
	}
	// set deleted
	pc._deleted = true
	return nil
}

// ProdCategoryByIDProdCategory retrieves a row from 'spc_holding.prod_category' as a ProdCategory.
//
// Generated from index 'prod_category_id_prod_category_pkey'.
func ProdCategoryByIDProdCategory(ctx context.Context, db DB, idProdCategory uint) (*ProdCategory, error) {
	// query
	const sqlstr = `SELECT ` +
		`id_prod_category, category_name, is_active_flag, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, CategoryId_old ` +
		`FROM spc_holding.prod_category ` +
		`WHERE id_prod_category = ?`
	// run
	logf(sqlstr, idProdCategory)
	pc := ProdCategory{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idProdCategory).Scan(&pc.IDProdCategory, &pc.CategoryName, &pc.IsActiveFlag, &pc.RecordCreateTime, &pc.RecordCreateByID, &pc.RecordCreateByName, &pc.RecordUpdateTime, &pc.RecordUpdateByID, &pc.RecordUpdateByName, &pc.CategoryIDOld); err != nil {
		return nil, logerror(err)
	}
	return &pc, nil
}
