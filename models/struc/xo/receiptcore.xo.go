package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// ReceiptCore represents a row from 'spc_holding.receipt_core'.
type ReceiptCore struct {
	IDReceiptCore       uint            `json:"id_receipt_core"`       // id_receipt_core
	IDDocCore           sql.NullInt64   `json:"id_doc_core"`           // id_doc_core
	IDDocType           sql.NullInt64   `json:"id_doc_type"`           // id_doc_type
	IDBranch            sql.NullInt64   `json:"id_branch"`             // id_branch
	IDActionName        sql.NullInt64   `json:"id_action_name"`        // id_action_name
	DocNumber           sql.NullString  `json:"doc_number"`            // doc_number
	DocRunning          sql.NullInt64   `json:"doc_running"`           // doc_running
	IDCustomer          sql.NullInt64   `json:"id_customer"`           // id_customer
	TmpCustFullname     sql.NullString  `json:"tmp_cust_fullname"`     // tmp_cust_fullname
	TmpCustNickname     sql.NullString  `json:"tmp_cust_nickname"`     // tmp_cust_nickname
	NoteCore            sql.NullString  `json:"note_core"`             // note_core
	TotalQuantity       sql.NullInt64   `json:"total_quantity"`        // total_quantity
	TotalPrice          sql.NullFloat64 `json:"total_price"`           // total_price
	TotalDownPayment    sql.NullFloat64 `json:"total_down_payment"`    // total_down_payment
	TotalAfterPayDown   sql.NullFloat64 `json:"total_after_pay_down"`  // total_after_pay_down
	TotalDiscountManual sql.NullFloat64 `json:"total_discount_manual"` // total_discount_manual
	TotalCalVat         sql.NullFloat64 `json:"total_cal_vat"`         // total_cal_vat
	TotalNetPrice       sql.NullFloat64 `json:"total_net_price"`       // total_net_price
	RecordCreateTime    sql.NullInt64   `json:"record_create_time"`    // record_create_time
	RecordCreateByID    sql.NullInt64   `json:"record_create_by_id"`   // record_create_by_id
	RecordCreateByName  sql.NullString  `json:"record_create_by_name"` // record_create_by_name
	RecordUpdateTime    sql.NullInt64   `json:"record_update_time"`    // record_update_time
	RecordUpdateByID    sql.NullInt64   `json:"record_update_by_id"`   // record_update_by_id
	RecordUpdateByName  sql.NullString  `json:"record_update_by_name"` // record_update_by_name
	IDSaleStaff         sql.NullInt64   `json:"id_sale_staff"`         // id_sale_staff
	TmpSaleStaffName    sql.NullInt64   `json:"tmp_sale_staff_name"`   // tmp_sale_staff_name
	MonthMm             sql.NullString  `json:"month_mm"`              // month_mm
	Year20yy            sql.NullString  `json:"year_20yy"`             // year_20yy
	FromSplit123        sql.NullBool    `json:"from_split_123"`        // from_split_123
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the ReceiptCore exists in the database.
func (rc *ReceiptCore) Exists() bool {
	return rc._exists
}

// Deleted returns true when the ReceiptCore has been marked for deletion from
// the database.
func (rc *ReceiptCore) Deleted() bool {
	return rc._deleted
}

// Insert inserts the ReceiptCore to the database.
func (rc *ReceiptCore) Insert(ctx context.Context, db DB) error {
	switch {
	case rc._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case rc._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO spc_holding.receipt_core (` +
		`id_doc_core, id_doc_type, id_branch, id_action_name, doc_number, doc_running, id_customer, tmp_cust_fullname, tmp_cust_nickname, note_core, total_quantity, total_price, total_down_payment, total_after_pay_down, total_discount_manual, total_cal_vat, total_net_price, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, id_sale_staff, tmp_sale_staff_name, month_mm, year_20yy, from_split_123` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, rc.IDDocCore, rc.IDDocType, rc.IDBranch, rc.IDActionName, rc.DocNumber, rc.DocRunning, rc.IDCustomer, rc.TmpCustFullname, rc.TmpCustNickname, rc.NoteCore, rc.TotalQuantity, rc.TotalPrice, rc.TotalDownPayment, rc.TotalAfterPayDown, rc.TotalDiscountManual, rc.TotalCalVat, rc.TotalNetPrice, rc.RecordCreateTime, rc.RecordCreateByID, rc.RecordCreateByName, rc.RecordUpdateTime, rc.RecordUpdateByID, rc.RecordUpdateByName, rc.IDSaleStaff, rc.TmpSaleStaffName, rc.MonthMm, rc.Year20yy, rc.FromSplit123)
	res, err := db.ExecContext(ctx, sqlstr, rc.IDDocCore, rc.IDDocType, rc.IDBranch, rc.IDActionName, rc.DocNumber, rc.DocRunning, rc.IDCustomer, rc.TmpCustFullname, rc.TmpCustNickname, rc.NoteCore, rc.TotalQuantity, rc.TotalPrice, rc.TotalDownPayment, rc.TotalAfterPayDown, rc.TotalDiscountManual, rc.TotalCalVat, rc.TotalNetPrice, rc.RecordCreateTime, rc.RecordCreateByID, rc.RecordCreateByName, rc.RecordUpdateTime, rc.RecordUpdateByID, rc.RecordUpdateByName, rc.IDSaleStaff, rc.TmpSaleStaffName, rc.MonthMm, rc.Year20yy, rc.FromSplit123)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	rc.IDReceiptCore = uint(id)
	// set exists
	rc._exists = true
	return nil
}

// Update updates a ReceiptCore in the database.
func (rc *ReceiptCore) Update(ctx context.Context, db DB) error {
	switch {
	case !rc._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case rc._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE spc_holding.receipt_core SET ` +
		`id_doc_core = ?, id_doc_type = ?, id_branch = ?, id_action_name = ?, doc_number = ?, doc_running = ?, id_customer = ?, tmp_cust_fullname = ?, tmp_cust_nickname = ?, note_core = ?, total_quantity = ?, total_price = ?, total_down_payment = ?, total_after_pay_down = ?, total_discount_manual = ?, total_cal_vat = ?, total_net_price = ?, record_create_time = ?, record_create_by_id = ?, record_create_by_name = ?, record_update_time = ?, record_update_by_id = ?, record_update_by_name = ?, id_sale_staff = ?, tmp_sale_staff_name = ?, month_mm = ?, year_20yy = ?, from_split_123 = ? ` +
		`WHERE id_receipt_core = ?`
	// run
	logf(sqlstr, rc.IDDocCore, rc.IDDocType, rc.IDBranch, rc.IDActionName, rc.DocNumber, rc.DocRunning, rc.IDCustomer, rc.TmpCustFullname, rc.TmpCustNickname, rc.NoteCore, rc.TotalQuantity, rc.TotalPrice, rc.TotalDownPayment, rc.TotalAfterPayDown, rc.TotalDiscountManual, rc.TotalCalVat, rc.TotalNetPrice, rc.RecordCreateTime, rc.RecordCreateByID, rc.RecordCreateByName, rc.RecordUpdateTime, rc.RecordUpdateByID, rc.RecordUpdateByName, rc.IDSaleStaff, rc.TmpSaleStaffName, rc.MonthMm, rc.Year20yy, rc.FromSplit123, rc.IDReceiptCore)
	if _, err := db.ExecContext(ctx, sqlstr, rc.IDDocCore, rc.IDDocType, rc.IDBranch, rc.IDActionName, rc.DocNumber, rc.DocRunning, rc.IDCustomer, rc.TmpCustFullname, rc.TmpCustNickname, rc.NoteCore, rc.TotalQuantity, rc.TotalPrice, rc.TotalDownPayment, rc.TotalAfterPayDown, rc.TotalDiscountManual, rc.TotalCalVat, rc.TotalNetPrice, rc.RecordCreateTime, rc.RecordCreateByID, rc.RecordCreateByName, rc.RecordUpdateTime, rc.RecordUpdateByID, rc.RecordUpdateByName, rc.IDSaleStaff, rc.TmpSaleStaffName, rc.MonthMm, rc.Year20yy, rc.FromSplit123, rc.IDReceiptCore); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the ReceiptCore to the database.
func (rc *ReceiptCore) Save(ctx context.Context, db DB) error {
	if rc.Exists() {
		return rc.Update(ctx, db)
	}
	return rc.Insert(ctx, db)
}

// Upsert performs an upsert for ReceiptCore.
func (rc *ReceiptCore) Upsert(ctx context.Context, db DB) error {
	switch {
	case rc._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO spc_holding.receipt_core (` +
		`id_receipt_core, id_doc_core, id_doc_type, id_branch, id_action_name, doc_number, doc_running, id_customer, tmp_cust_fullname, tmp_cust_nickname, note_core, total_quantity, total_price, total_down_payment, total_after_pay_down, total_discount_manual, total_cal_vat, total_net_price, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, id_sale_staff, tmp_sale_staff_name, month_mm, year_20yy, from_split_123` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`id_doc_core = VALUES(id_doc_core), id_doc_type = VALUES(id_doc_type), id_branch = VALUES(id_branch), id_action_name = VALUES(id_action_name), doc_number = VALUES(doc_number), doc_running = VALUES(doc_running), id_customer = VALUES(id_customer), tmp_cust_fullname = VALUES(tmp_cust_fullname), tmp_cust_nickname = VALUES(tmp_cust_nickname), note_core = VALUES(note_core), total_quantity = VALUES(total_quantity), total_price = VALUES(total_price), total_down_payment = VALUES(total_down_payment), total_after_pay_down = VALUES(total_after_pay_down), total_discount_manual = VALUES(total_discount_manual), total_cal_vat = VALUES(total_cal_vat), total_net_price = VALUES(total_net_price), record_create_time = VALUES(record_create_time), record_create_by_id = VALUES(record_create_by_id), record_create_by_name = VALUES(record_create_by_name), record_update_time = VALUES(record_update_time), record_update_by_id = VALUES(record_update_by_id), record_update_by_name = VALUES(record_update_by_name), id_sale_staff = VALUES(id_sale_staff), tmp_sale_staff_name = VALUES(tmp_sale_staff_name), month_mm = VALUES(month_mm), year_20yy = VALUES(year_20yy), from_split_123 = VALUES(from_split_123)`
	// run
	logf(sqlstr, rc.IDReceiptCore, rc.IDDocCore, rc.IDDocType, rc.IDBranch, rc.IDActionName, rc.DocNumber, rc.DocRunning, rc.IDCustomer, rc.TmpCustFullname, rc.TmpCustNickname, rc.NoteCore, rc.TotalQuantity, rc.TotalPrice, rc.TotalDownPayment, rc.TotalAfterPayDown, rc.TotalDiscountManual, rc.TotalCalVat, rc.TotalNetPrice, rc.RecordCreateTime, rc.RecordCreateByID, rc.RecordCreateByName, rc.RecordUpdateTime, rc.RecordUpdateByID, rc.RecordUpdateByName, rc.IDSaleStaff, rc.TmpSaleStaffName, rc.MonthMm, rc.Year20yy, rc.FromSplit123)
	if _, err := db.ExecContext(ctx, sqlstr, rc.IDReceiptCore, rc.IDDocCore, rc.IDDocType, rc.IDBranch, rc.IDActionName, rc.DocNumber, rc.DocRunning, rc.IDCustomer, rc.TmpCustFullname, rc.TmpCustNickname, rc.NoteCore, rc.TotalQuantity, rc.TotalPrice, rc.TotalDownPayment, rc.TotalAfterPayDown, rc.TotalDiscountManual, rc.TotalCalVat, rc.TotalNetPrice, rc.RecordCreateTime, rc.RecordCreateByID, rc.RecordCreateByName, rc.RecordUpdateTime, rc.RecordUpdateByID, rc.RecordUpdateByName, rc.IDSaleStaff, rc.TmpSaleStaffName, rc.MonthMm, rc.Year20yy, rc.FromSplit123); err != nil {
		return logerror(err)
	}
	// set exists
	rc._exists = true
	return nil
}

// Delete deletes the ReceiptCore from the database.
func (rc *ReceiptCore) Delete(ctx context.Context, db DB) error {
	switch {
	case !rc._exists: // doesn't exist
		return nil
	case rc._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM spc_holding.receipt_core ` +
		`WHERE id_receipt_core = ?`
	// run
	logf(sqlstr, rc.IDReceiptCore)
	if _, err := db.ExecContext(ctx, sqlstr, rc.IDReceiptCore); err != nil {
		return logerror(err)
	}
	// set deleted
	rc._deleted = true
	return nil
}

// ReceiptCoreByIDReceiptCore retrieves a row from 'spc_holding.receipt_core' as a ReceiptCore.
//
// Generated from index 'receipt_core_id_receipt_core_pkey'.
func ReceiptCoreByIDReceiptCore(ctx context.Context, db DB, idReceiptCore uint) (*ReceiptCore, error) {
	// query
	const sqlstr = `SELECT ` +
		`id_receipt_core, id_doc_core, id_doc_type, id_branch, id_action_name, doc_number, doc_running, id_customer, tmp_cust_fullname, tmp_cust_nickname, note_core, total_quantity, total_price, total_down_payment, total_after_pay_down, total_discount_manual, total_cal_vat, total_net_price, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, id_sale_staff, tmp_sale_staff_name, month_mm, year_20yy, from_split_123 ` +
		`FROM spc_holding.receipt_core ` +
		`WHERE id_receipt_core = ?`
	// run
	logf(sqlstr, idReceiptCore)
	rc := ReceiptCore{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idReceiptCore).Scan(&rc.IDReceiptCore, &rc.IDDocCore, &rc.IDDocType, &rc.IDBranch, &rc.IDActionName, &rc.DocNumber, &rc.DocRunning, &rc.IDCustomer, &rc.TmpCustFullname, &rc.TmpCustNickname, &rc.NoteCore, &rc.TotalQuantity, &rc.TotalPrice, &rc.TotalDownPayment, &rc.TotalAfterPayDown, &rc.TotalDiscountManual, &rc.TotalCalVat, &rc.TotalNetPrice, &rc.RecordCreateTime, &rc.RecordCreateByID, &rc.RecordCreateByName, &rc.RecordUpdateTime, &rc.RecordUpdateByID, &rc.RecordUpdateByName, &rc.IDSaleStaff, &rc.TmpSaleStaffName, &rc.MonthMm, &rc.Year20yy, &rc.FromSplit123); err != nil {
		return nil, logerror(err)
	}
	return &rc, nil
}
