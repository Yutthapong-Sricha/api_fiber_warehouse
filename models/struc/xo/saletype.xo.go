package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// SaleType represents a row from 'spc_holding.sale_type'.
type SaleType struct {
	IDSaleType       uint           `json:"id_sale_type"`        // id_sale_type
	SaleTypeName     sql.NullString `json:"sale_type_name"`      // sale_type_name
	IDProduct        sql.NullInt64  `json:"id_product"`          // id_product
	RowOrderSaleType sql.NullInt64  `json:"row_order_sale_type"` // row_order_sale_type
	IsShow356        sql.NullBool   `json:"is_show_356"`         // is_show_356
	IsActiveFlag     sql.NullBool   `json:"is_active_flag"`      // is_active_flag
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the SaleType exists in the database.
func (st *SaleType) Exists() bool {
	return st._exists
}

// Deleted returns true when the SaleType has been marked for deletion from
// the database.
func (st *SaleType) Deleted() bool {
	return st._deleted
}

// Insert inserts the SaleType to the database.
func (st *SaleType) Insert(ctx context.Context, db DB) error {
	switch {
	case st._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case st._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO spc_holding.sale_type (` +
		`sale_type_name, id_product, row_order_sale_type, is_show_356, is_active_flag` +
		`) VALUES (` +
		`?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, st.SaleTypeName, st.IDProduct, st.RowOrderSaleType, st.IsShow356, st.IsActiveFlag)
	res, err := db.ExecContext(ctx, sqlstr, st.SaleTypeName, st.IDProduct, st.RowOrderSaleType, st.IsShow356, st.IsActiveFlag)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	st.IDSaleType = uint(id)
	// set exists
	st._exists = true
	return nil
}

// Update updates a SaleType in the database.
func (st *SaleType) Update(ctx context.Context, db DB) error {
	switch {
	case !st._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case st._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE spc_holding.sale_type SET ` +
		`sale_type_name = ?, id_product = ?, row_order_sale_type = ?, is_show_356 = ?, is_active_flag = ? ` +
		`WHERE id_sale_type = ?`
	// run
	logf(sqlstr, st.SaleTypeName, st.IDProduct, st.RowOrderSaleType, st.IsShow356, st.IsActiveFlag, st.IDSaleType)
	if _, err := db.ExecContext(ctx, sqlstr, st.SaleTypeName, st.IDProduct, st.RowOrderSaleType, st.IsShow356, st.IsActiveFlag, st.IDSaleType); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the SaleType to the database.
func (st *SaleType) Save(ctx context.Context, db DB) error {
	if st.Exists() {
		return st.Update(ctx, db)
	}
	return st.Insert(ctx, db)
}

// Upsert performs an upsert for SaleType.
func (st *SaleType) Upsert(ctx context.Context, db DB) error {
	switch {
	case st._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO spc_holding.sale_type (` +
		`id_sale_type, sale_type_name, id_product, row_order_sale_type, is_show_356, is_active_flag` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`sale_type_name = VALUES(sale_type_name), id_product = VALUES(id_product), row_order_sale_type = VALUES(row_order_sale_type), is_show_356 = VALUES(is_show_356), is_active_flag = VALUES(is_active_flag)`
	// run
	logf(sqlstr, st.IDSaleType, st.SaleTypeName, st.IDProduct, st.RowOrderSaleType, st.IsShow356, st.IsActiveFlag)
	if _, err := db.ExecContext(ctx, sqlstr, st.IDSaleType, st.SaleTypeName, st.IDProduct, st.RowOrderSaleType, st.IsShow356, st.IsActiveFlag); err != nil {
		return logerror(err)
	}
	// set exists
	st._exists = true
	return nil
}

// Delete deletes the SaleType from the database.
func (st *SaleType) Delete(ctx context.Context, db DB) error {
	switch {
	case !st._exists: // doesn't exist
		return nil
	case st._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM spc_holding.sale_type ` +
		`WHERE id_sale_type = ?`
	// run
	logf(sqlstr, st.IDSaleType)
	if _, err := db.ExecContext(ctx, sqlstr, st.IDSaleType); err != nil {
		return logerror(err)
	}
	// set deleted
	st._deleted = true
	return nil
}

// SaleTypeByIDSaleType retrieves a row from 'spc_holding.sale_type' as a SaleType.
//
// Generated from index 'sale_type_id_sale_type_pkey'.
func SaleTypeByIDSaleType(ctx context.Context, db DB, idsaleType uint) (*SaleType, error) {
	// query
	const sqlstr = `SELECT ` +
		`id_sale_type, sale_type_name, id_product, row_order_sale_type, is_show_356, is_active_flag ` +
		`FROM spc_holding.sale_type ` +
		`WHERE id_sale_type = ?`
	// run
	logf(sqlstr, idsaleType)
	st := SaleType{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idsaleType).Scan(&st.IDSaleType, &st.SaleTypeName, &st.IDProduct, &st.RowOrderSaleType, &st.IsShow356, &st.IsActiveFlag); err != nil {
		return nil, logerror(err)
	}
	return &st, nil
}
