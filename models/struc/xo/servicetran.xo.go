package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// ServiceTran represents a row from 'spc_holding.service_trans'.
type ServiceTran struct {
	IDServiceTrans      uint            `json:"id_service_trans"`      // id_service_trans
	IDDocCore           sql.NullInt64   `json:"id_doc_core"`           // id_doc_core
	ServiceDateDdmm20yy sql.NullString  `json:"service_date_ddmm20yy"` // service_date_ddmm20yy
	ServiceDateInt      sql.NullInt64   `json:"service_date_int"`      // service_date_int
	MonthMm             sql.NullString  `json:"month_mm"`              // month_mm
	Year20yy            sql.NullString  `json:"year_20yy"`             // year_20yy
	IDJobTemplate       sql.NullInt64   `json:"id_job_template"`       // id_job_template
	IDStaffCore         sql.NullInt64   `json:"id_staff_core"`         // id_staff_core
	Detail              sql.NullInt64   `json:"detail"`                // detail
	TmpStaffName        sql.NullString  `json:"tmp_staff_name"`        // tmp_staff_name
	RefIDStockCore      sql.NullInt64   `json:"ref_id_stock_core"`     // ref_id_stock_core
	QtyOrder            sql.NullInt64   `json:"qty_order"`             // qty_order
	QtyUsed             sql.NullInt64   `json:"qty_used"`              // qty_used
	Price               sql.NullFloat64 `json:"price"`                 // price
	Done356             sql.NullBool    `json:"done_356"`              // done_356
	RecordCreateTime    sql.NullInt64   `json:"record_create_time"`    // record_create_time
	RecordCreateByID    sql.NullInt64   `json:"record_create_by_id"`   // record_create_by_id
	RecordCreateByName  sql.NullString  `json:"record_create_by_name"` // record_create_by_name
	RecordUpdateTime    sql.NullInt64   `json:"record_update_time"`    // record_update_time
	RecordUpdateByID    sql.NullInt64   `json:"record_update_by_id"`   // record_update_by_id
	RecordUpdateByName  sql.NullString  `json:"record_update_by_name"` // record_update_by_name
	TransClose356       sql.NullBool    `json:"trans_close_356"`       // trans_close_356
	TransCloseTime      sql.NullInt64   `json:"trans_close_time"`      // trans_close_time
	TransCloseByID      sql.NullInt64   `json:"trans_close_by_id"`     // trans_close_by_id
	TransCloseByName    sql.NullString  `json:"trans_close_by_name"`   // trans_close_by_name
	HasEditTransFlag    sql.NullBool    `json:"has_edit_trans_flag"`   // has_edit_trans_flag
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the ServiceTran exists in the database.
func (st *ServiceTran) Exists() bool {
	return st._exists
}

// Deleted returns true when the ServiceTran has been marked for deletion from
// the database.
func (st *ServiceTran) Deleted() bool {
	return st._deleted
}

// Insert inserts the ServiceTran to the database.
func (st *ServiceTran) Insert(ctx context.Context, db DB) error {
	switch {
	case st._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case st._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO spc_holding.service_trans (` +
		`id_doc_core, service_date_ddmm20yy, service_date_int, month_mm, year_20yy, id_job_template, id_staff_core, detail, tmp_staff_name, ref_id_stock_core, qty_order, qty_used, price, done_356, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, trans_close_356, trans_close_time, trans_close_by_id, trans_close_by_name, has_edit_trans_flag` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, st.IDDocCore, st.ServiceDateDdmm20yy, st.ServiceDateInt, st.MonthMm, st.Year20yy, st.IDJobTemplate, st.IDStaffCore, st.Detail, st.TmpStaffName, st.RefIDStockCore, st.QtyOrder, st.QtyUsed, st.Price, st.Done356, st.RecordCreateTime, st.RecordCreateByID, st.RecordCreateByName, st.RecordUpdateTime, st.RecordUpdateByID, st.RecordUpdateByName, st.TransClose356, st.TransCloseTime, st.TransCloseByID, st.TransCloseByName, st.HasEditTransFlag)
	res, err := db.ExecContext(ctx, sqlstr, st.IDDocCore, st.ServiceDateDdmm20yy, st.ServiceDateInt, st.MonthMm, st.Year20yy, st.IDJobTemplate, st.IDStaffCore, st.Detail, st.TmpStaffName, st.RefIDStockCore, st.QtyOrder, st.QtyUsed, st.Price, st.Done356, st.RecordCreateTime, st.RecordCreateByID, st.RecordCreateByName, st.RecordUpdateTime, st.RecordUpdateByID, st.RecordUpdateByName, st.TransClose356, st.TransCloseTime, st.TransCloseByID, st.TransCloseByName, st.HasEditTransFlag)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	st.IDServiceTrans = uint(id)
	// set exists
	st._exists = true
	return nil
}

// Update updates a ServiceTran in the database.
func (st *ServiceTran) Update(ctx context.Context, db DB) error {
	switch {
	case !st._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case st._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE spc_holding.service_trans SET ` +
		`id_doc_core = ?, service_date_ddmm20yy = ?, service_date_int = ?, month_mm = ?, year_20yy = ?, id_job_template = ?, id_staff_core = ?, detail = ?, tmp_staff_name = ?, ref_id_stock_core = ?, qty_order = ?, qty_used = ?, price = ?, done_356 = ?, record_create_time = ?, record_create_by_id = ?, record_create_by_name = ?, record_update_time = ?, record_update_by_id = ?, record_update_by_name = ?, trans_close_356 = ?, trans_close_time = ?, trans_close_by_id = ?, trans_close_by_name = ?, has_edit_trans_flag = ? ` +
		`WHERE id_service_trans = ?`
	// run
	logf(sqlstr, st.IDDocCore, st.ServiceDateDdmm20yy, st.ServiceDateInt, st.MonthMm, st.Year20yy, st.IDJobTemplate, st.IDStaffCore, st.Detail, st.TmpStaffName, st.RefIDStockCore, st.QtyOrder, st.QtyUsed, st.Price, st.Done356, st.RecordCreateTime, st.RecordCreateByID, st.RecordCreateByName, st.RecordUpdateTime, st.RecordUpdateByID, st.RecordUpdateByName, st.TransClose356, st.TransCloseTime, st.TransCloseByID, st.TransCloseByName, st.HasEditTransFlag, st.IDServiceTrans)
	if _, err := db.ExecContext(ctx, sqlstr, st.IDDocCore, st.ServiceDateDdmm20yy, st.ServiceDateInt, st.MonthMm, st.Year20yy, st.IDJobTemplate, st.IDStaffCore, st.Detail, st.TmpStaffName, st.RefIDStockCore, st.QtyOrder, st.QtyUsed, st.Price, st.Done356, st.RecordCreateTime, st.RecordCreateByID, st.RecordCreateByName, st.RecordUpdateTime, st.RecordUpdateByID, st.RecordUpdateByName, st.TransClose356, st.TransCloseTime, st.TransCloseByID, st.TransCloseByName, st.HasEditTransFlag, st.IDServiceTrans); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the ServiceTran to the database.
func (st *ServiceTran) Save(ctx context.Context, db DB) error {
	if st.Exists() {
		return st.Update(ctx, db)
	}
	return st.Insert(ctx, db)
}

// Upsert performs an upsert for ServiceTran.
func (st *ServiceTran) Upsert(ctx context.Context, db DB) error {
	switch {
	case st._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO spc_holding.service_trans (` +
		`id_service_trans, id_doc_core, service_date_ddmm20yy, service_date_int, month_mm, year_20yy, id_job_template, id_staff_core, detail, tmp_staff_name, ref_id_stock_core, qty_order, qty_used, price, done_356, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, trans_close_356, trans_close_time, trans_close_by_id, trans_close_by_name, has_edit_trans_flag` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`id_doc_core = VALUES(id_doc_core), service_date_ddmm20yy = VALUES(service_date_ddmm20yy), service_date_int = VALUES(service_date_int), month_mm = VALUES(month_mm), year_20yy = VALUES(year_20yy), id_job_template = VALUES(id_job_template), id_staff_core = VALUES(id_staff_core), detail = VALUES(detail), tmp_staff_name = VALUES(tmp_staff_name), ref_id_stock_core = VALUES(ref_id_stock_core), qty_order = VALUES(qty_order), qty_used = VALUES(qty_used), price = VALUES(price), done_356 = VALUES(done_356), record_create_time = VALUES(record_create_time), record_create_by_id = VALUES(record_create_by_id), record_create_by_name = VALUES(record_create_by_name), record_update_time = VALUES(record_update_time), record_update_by_id = VALUES(record_update_by_id), record_update_by_name = VALUES(record_update_by_name), trans_close_356 = VALUES(trans_close_356), trans_close_time = VALUES(trans_close_time), trans_close_by_id = VALUES(trans_close_by_id), trans_close_by_name = VALUES(trans_close_by_name), has_edit_trans_flag = VALUES(has_edit_trans_flag)`
	// run
	logf(sqlstr, st.IDServiceTrans, st.IDDocCore, st.ServiceDateDdmm20yy, st.ServiceDateInt, st.MonthMm, st.Year20yy, st.IDJobTemplate, st.IDStaffCore, st.Detail, st.TmpStaffName, st.RefIDStockCore, st.QtyOrder, st.QtyUsed, st.Price, st.Done356, st.RecordCreateTime, st.RecordCreateByID, st.RecordCreateByName, st.RecordUpdateTime, st.RecordUpdateByID, st.RecordUpdateByName, st.TransClose356, st.TransCloseTime, st.TransCloseByID, st.TransCloseByName, st.HasEditTransFlag)
	if _, err := db.ExecContext(ctx, sqlstr, st.IDServiceTrans, st.IDDocCore, st.ServiceDateDdmm20yy, st.ServiceDateInt, st.MonthMm, st.Year20yy, st.IDJobTemplate, st.IDStaffCore, st.Detail, st.TmpStaffName, st.RefIDStockCore, st.QtyOrder, st.QtyUsed, st.Price, st.Done356, st.RecordCreateTime, st.RecordCreateByID, st.RecordCreateByName, st.RecordUpdateTime, st.RecordUpdateByID, st.RecordUpdateByName, st.TransClose356, st.TransCloseTime, st.TransCloseByID, st.TransCloseByName, st.HasEditTransFlag); err != nil {
		return logerror(err)
	}
	// set exists
	st._exists = true
	return nil
}

// Delete deletes the ServiceTran from the database.
func (st *ServiceTran) Delete(ctx context.Context, db DB) error {
	switch {
	case !st._exists: // doesn't exist
		return nil
	case st._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM spc_holding.service_trans ` +
		`WHERE id_service_trans = ?`
	// run
	logf(sqlstr, st.IDServiceTrans)
	if _, err := db.ExecContext(ctx, sqlstr, st.IDServiceTrans); err != nil {
		return logerror(err)
	}
	// set deleted
	st._deleted = true
	return nil
}

// ServiceTranByIDServiceTrans retrieves a row from 'spc_holding.service_trans' as a ServiceTran.
//
// Generated from index 'service_trans_id_service_trans_pkey'.
func ServiceTranByIDServiceTrans(ctx context.Context, db DB, idserviceTrans uint) (*ServiceTran, error) {
	// query
	const sqlstr = `SELECT ` +
		`id_service_trans, id_doc_core, service_date_ddmm20yy, service_date_int, month_mm, year_20yy, id_job_template, id_staff_core, detail, tmp_staff_name, ref_id_stock_core, qty_order, qty_used, price, done_356, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, trans_close_356, trans_close_time, trans_close_by_id, trans_close_by_name, has_edit_trans_flag ` +
		`FROM spc_holding.service_trans ` +
		`WHERE id_service_trans = ?`
	// run
	logf(sqlstr, idserviceTrans)
	st := ServiceTran{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idserviceTrans).Scan(&st.IDServiceTrans, &st.IDDocCore, &st.ServiceDateDdmm20yy, &st.ServiceDateInt, &st.MonthMm, &st.Year20yy, &st.IDJobTemplate, &st.IDStaffCore, &st.Detail, &st.TmpStaffName, &st.RefIDStockCore, &st.QtyOrder, &st.QtyUsed, &st.Price, &st.Done356, &st.RecordCreateTime, &st.RecordCreateByID, &st.RecordCreateByName, &st.RecordUpdateTime, &st.RecordUpdateByID, &st.RecordUpdateByName, &st.TransClose356, &st.TransCloseTime, &st.TransCloseByID, &st.TransCloseByName, &st.HasEditTransFlag); err != nil {
		return nil, logerror(err)
	}
	return &st, nil
}
