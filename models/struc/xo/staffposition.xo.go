package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// StaffPosition represents a row from 'spc_holding.staff_position'.
type StaffPosition struct {
	IDStaffPosition    uint           `json:"id_staff_position"`     // id_staff_position
	PositionName       sql.NullString `json:"position_name"`         // position_name
	RowOrderPosition   sql.NullInt64  `json:"row_order_position"`    // row_order_position
	IsActiveFlag       sql.NullBool   `json:"is_active_flag"`        // is_active_flag
	RecordUpdateTime   sql.NullInt64  `json:"record_update_time"`    // record_update_time
	RecordUpdateByID   sql.NullInt64  `json:"record_update_by_id"`   // record_update_by_id
	RecordUpdateByName sql.NullString `json:"record_update_by_name"` // record_update_by_name
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the StaffPosition exists in the database.
func (sp *StaffPosition) Exists() bool {
	return sp._exists
}

// Deleted returns true when the StaffPosition has been marked for deletion from
// the database.
func (sp *StaffPosition) Deleted() bool {
	return sp._deleted
}

// Insert inserts the StaffPosition to the database.
func (sp *StaffPosition) Insert(ctx context.Context, db DB) error {
	switch {
	case sp._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case sp._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO spc_holding.staff_position (` +
		`position_name, row_order_position, is_active_flag, record_update_time, record_update_by_id, record_update_by_name` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, sp.PositionName, sp.RowOrderPosition, sp.IsActiveFlag, sp.RecordUpdateTime, sp.RecordUpdateByID, sp.RecordUpdateByName)
	res, err := db.ExecContext(ctx, sqlstr, sp.PositionName, sp.RowOrderPosition, sp.IsActiveFlag, sp.RecordUpdateTime, sp.RecordUpdateByID, sp.RecordUpdateByName)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	sp.IDStaffPosition = uint(id)
	// set exists
	sp._exists = true
	return nil
}

// Update updates a StaffPosition in the database.
func (sp *StaffPosition) Update(ctx context.Context, db DB) error {
	switch {
	case !sp._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case sp._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE spc_holding.staff_position SET ` +
		`position_name = ?, row_order_position = ?, is_active_flag = ?, record_update_time = ?, record_update_by_id = ?, record_update_by_name = ? ` +
		`WHERE id_staff_position = ?`
	// run
	logf(sqlstr, sp.PositionName, sp.RowOrderPosition, sp.IsActiveFlag, sp.RecordUpdateTime, sp.RecordUpdateByID, sp.RecordUpdateByName, sp.IDStaffPosition)
	if _, err := db.ExecContext(ctx, sqlstr, sp.PositionName, sp.RowOrderPosition, sp.IsActiveFlag, sp.RecordUpdateTime, sp.RecordUpdateByID, sp.RecordUpdateByName, sp.IDStaffPosition); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the StaffPosition to the database.
func (sp *StaffPosition) Save(ctx context.Context, db DB) error {
	if sp.Exists() {
		return sp.Update(ctx, db)
	}
	return sp.Insert(ctx, db)
}

// Upsert performs an upsert for StaffPosition.
func (sp *StaffPosition) Upsert(ctx context.Context, db DB) error {
	switch {
	case sp._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO spc_holding.staff_position (` +
		`id_staff_position, position_name, row_order_position, is_active_flag, record_update_time, record_update_by_id, record_update_by_name` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`position_name = VALUES(position_name), row_order_position = VALUES(row_order_position), is_active_flag = VALUES(is_active_flag), record_update_time = VALUES(record_update_time), record_update_by_id = VALUES(record_update_by_id), record_update_by_name = VALUES(record_update_by_name)`
	// run
	logf(sqlstr, sp.IDStaffPosition, sp.PositionName, sp.RowOrderPosition, sp.IsActiveFlag, sp.RecordUpdateTime, sp.RecordUpdateByID, sp.RecordUpdateByName)
	if _, err := db.ExecContext(ctx, sqlstr, sp.IDStaffPosition, sp.PositionName, sp.RowOrderPosition, sp.IsActiveFlag, sp.RecordUpdateTime, sp.RecordUpdateByID, sp.RecordUpdateByName); err != nil {
		return logerror(err)
	}
	// set exists
	sp._exists = true
	return nil
}

// Delete deletes the StaffPosition from the database.
func (sp *StaffPosition) Delete(ctx context.Context, db DB) error {
	switch {
	case !sp._exists: // doesn't exist
		return nil
	case sp._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM spc_holding.staff_position ` +
		`WHERE id_staff_position = ?`
	// run
	logf(sqlstr, sp.IDStaffPosition)
	if _, err := db.ExecContext(ctx, sqlstr, sp.IDStaffPosition); err != nil {
		return logerror(err)
	}
	// set deleted
	sp._deleted = true
	return nil
}

// StaffPositionByIDStaffPosition retrieves a row from 'spc_holding.staff_position' as a StaffPosition.
//
// Generated from index 'staff_position_id_staff_position_pkey'.
func StaffPositionByIDStaffPosition(ctx context.Context, db DB, idstaffPosition uint) (*StaffPosition, error) {
	// query
	const sqlstr = `SELECT ` +
		`id_staff_position, position_name, row_order_position, is_active_flag, record_update_time, record_update_by_id, record_update_by_name ` +
		`FROM spc_holding.staff_position ` +
		`WHERE id_staff_position = ?`
	// run
	logf(sqlstr, idstaffPosition)
	sp := StaffPosition{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idstaffPosition).Scan(&sp.IDStaffPosition, &sp.PositionName, &sp.RowOrderPosition, &sp.IsActiveFlag, &sp.RecordUpdateTime, &sp.RecordUpdateByID, &sp.RecordUpdateByName); err != nil {
		return nil, logerror(err)
	}
	return &sp, nil
}
