package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// StockTran represents a row from 'spc_holding.stock_trans'.
type StockTran struct {
	IDStockTrans       uint            `json:"id_stock_trans"`        // id_stock_trans
	IDDocInTrans       sql.NullInt64   `json:"id_doc_in_trans"`       // id_doc_in_trans
	IDDocOutTrans      sql.NullInt64   `json:"id_doc_out_trans"`      // id_doc_out_trans
	IDBranch           sql.NullInt64   `json:"id_branch"`             // id_branch
	IDDocStatus        sql.NullInt64   `json:"id_doc_status"`         // id_doc_status
	IDStockCore        sql.NullInt64   `json:"id_stock_core"`         // id_stock_core
	IDProduct          sql.NullInt64   `json:"id_product"`            // id_product
	IDSupplier         sql.NullInt64   `json:"id_supplier"`           // id_supplier
	TmpProductName     sql.NullInt64   `json:"tmp_product_name"`      // tmp_product_name
	EngineNo           sql.NullString  `json:"engine_no"`             // engine_no
	SerialNo           sql.NullString  `json:"serial_no"`             // serial_no
	IsVolumeFlag       sql.NullBool    `json:"is_volume_flag"`        // is_volume_flag
	IsFreebiesFlag     sql.NullBool    `json:"is_freebies_flag"`      // is_freebies_flag
	QtyInCost          sql.NullInt64   `json:"qty_in_cost"`           // qty_in_cost
	QtyInFree          sql.NullInt64   `json:"qty_in_free"`           // qty_in_free
	QtyOutCost         sql.NullInt64   `json:"qty_out_cost"`          // qty_out_cost
	QtyOutFree         sql.NullInt64   `json:"qty_out_free"`          // qty_out_free
	PricePerUnit       sql.NullFloat64 `json:"price_per_unit"`        // price_per_unit
	TotalPrice         sql.NullFloat64 `json:"total_price"`           // total_price
	DownPayment        sql.NullFloat64 `json:"down_payment"`          // down_payment
	AfterPayDown       sql.NullFloat64 `json:"after_pay_down"`        // after_pay_down
	NetPrice           sql.NullFloat64 `json:"net_price"`             // net_price
	RecordCreateTime   sql.NullInt64   `json:"record_create_time"`    // record_create_time
	RecordCreateByID   sql.NullInt64   `json:"record_create_by_id"`   // record_create_by_id
	RecordCreateByName sql.NullString  `json:"record_create_by_name"` // record_create_by_name
	RecordUpdateTime   sql.NullInt64   `json:"record_update_time"`    // record_update_time
	RecordUpdateByID   sql.NullInt64   `json:"record_update_by_id"`   // record_update_by_id
	RecordUpdateByName sql.NullString  `json:"record_update_by_name"` // record_update_by_name
	MonthMm            sql.NullString  `json:"month_mm"`              // month_mm
	Year20yy           sql.NullString  `json:"year_20yy"`             // year_20yy
	Barcode            sql.NullString  `json:"barcode"`               // barcode
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the StockTran exists in the database.
func (st *StockTran) Exists() bool {
	return st._exists
}

// Deleted returns true when the StockTran has been marked for deletion from
// the database.
func (st *StockTran) Deleted() bool {
	return st._deleted
}

// Insert inserts the StockTran to the database.
func (st *StockTran) Insert(ctx context.Context, db DB) error {
	switch {
	case st._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case st._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO spc_holding.stock_trans (` +
		`id_doc_in_trans, id_doc_out_trans, id_branch, id_doc_status, id_stock_core, id_product, id_supplier, tmp_product_name, engine_no, serial_no, is_volume_flag, is_freebies_flag, qty_in_cost, qty_in_free, qty_out_cost, qty_out_free, price_per_unit, total_price, down_payment, after_pay_down, net_price, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, month_mm, year_20yy, barcode` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, st.IDDocInTrans, st.IDDocOutTrans, st.IDBranch, st.IDDocStatus, st.IDStockCore, st.IDProduct, st.IDSupplier, st.TmpProductName, st.EngineNo, st.SerialNo, st.IsVolumeFlag, st.IsFreebiesFlag, st.QtyInCost, st.QtyInFree, st.QtyOutCost, st.QtyOutFree, st.PricePerUnit, st.TotalPrice, st.DownPayment, st.AfterPayDown, st.NetPrice, st.RecordCreateTime, st.RecordCreateByID, st.RecordCreateByName, st.RecordUpdateTime, st.RecordUpdateByID, st.RecordUpdateByName, st.MonthMm, st.Year20yy, st.Barcode)
	res, err := db.ExecContext(ctx, sqlstr, st.IDDocInTrans, st.IDDocOutTrans, st.IDBranch, st.IDDocStatus, st.IDStockCore, st.IDProduct, st.IDSupplier, st.TmpProductName, st.EngineNo, st.SerialNo, st.IsVolumeFlag, st.IsFreebiesFlag, st.QtyInCost, st.QtyInFree, st.QtyOutCost, st.QtyOutFree, st.PricePerUnit, st.TotalPrice, st.DownPayment, st.AfterPayDown, st.NetPrice, st.RecordCreateTime, st.RecordCreateByID, st.RecordCreateByName, st.RecordUpdateTime, st.RecordUpdateByID, st.RecordUpdateByName, st.MonthMm, st.Year20yy, st.Barcode)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	st.IDStockTrans = uint(id)
	// set exists
	st._exists = true
	return nil
}

// Update updates a StockTran in the database.
func (st *StockTran) Update(ctx context.Context, db DB) error {
	switch {
	case !st._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case st._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE spc_holding.stock_trans SET ` +
		`id_doc_in_trans = ?, id_doc_out_trans = ?, id_branch = ?, id_doc_status = ?, id_stock_core = ?, id_product = ?, id_supplier = ?, tmp_product_name = ?, engine_no = ?, serial_no = ?, is_volume_flag = ?, is_freebies_flag = ?, qty_in_cost = ?, qty_in_free = ?, qty_out_cost = ?, qty_out_free = ?, price_per_unit = ?, total_price = ?, down_payment = ?, after_pay_down = ?, net_price = ?, record_create_time = ?, record_create_by_id = ?, record_create_by_name = ?, record_update_time = ?, record_update_by_id = ?, record_update_by_name = ?, month_mm = ?, year_20yy = ?, barcode = ? ` +
		`WHERE id_stock_trans = ?`
	// run
	logf(sqlstr, st.IDDocInTrans, st.IDDocOutTrans, st.IDBranch, st.IDDocStatus, st.IDStockCore, st.IDProduct, st.IDSupplier, st.TmpProductName, st.EngineNo, st.SerialNo, st.IsVolumeFlag, st.IsFreebiesFlag, st.QtyInCost, st.QtyInFree, st.QtyOutCost, st.QtyOutFree, st.PricePerUnit, st.TotalPrice, st.DownPayment, st.AfterPayDown, st.NetPrice, st.RecordCreateTime, st.RecordCreateByID, st.RecordCreateByName, st.RecordUpdateTime, st.RecordUpdateByID, st.RecordUpdateByName, st.MonthMm, st.Year20yy, st.Barcode, st.IDStockTrans)
	if _, err := db.ExecContext(ctx, sqlstr, st.IDDocInTrans, st.IDDocOutTrans, st.IDBranch, st.IDDocStatus, st.IDStockCore, st.IDProduct, st.IDSupplier, st.TmpProductName, st.EngineNo, st.SerialNo, st.IsVolumeFlag, st.IsFreebiesFlag, st.QtyInCost, st.QtyInFree, st.QtyOutCost, st.QtyOutFree, st.PricePerUnit, st.TotalPrice, st.DownPayment, st.AfterPayDown, st.NetPrice, st.RecordCreateTime, st.RecordCreateByID, st.RecordCreateByName, st.RecordUpdateTime, st.RecordUpdateByID, st.RecordUpdateByName, st.MonthMm, st.Year20yy, st.Barcode, st.IDStockTrans); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the StockTran to the database.
func (st *StockTran) Save(ctx context.Context, db DB) error {
	if st.Exists() {
		return st.Update(ctx, db)
	}
	return st.Insert(ctx, db)
}

// Upsert performs an upsert for StockTran.
func (st *StockTran) Upsert(ctx context.Context, db DB) error {
	switch {
	case st._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO spc_holding.stock_trans (` +
		`id_stock_trans, id_doc_in_trans, id_doc_out_trans, id_branch, id_doc_status, id_stock_core, id_product, id_supplier, tmp_product_name, engine_no, serial_no, is_volume_flag, is_freebies_flag, qty_in_cost, qty_in_free, qty_out_cost, qty_out_free, price_per_unit, total_price, down_payment, after_pay_down, net_price, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, month_mm, year_20yy, barcode` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`id_doc_in_trans = VALUES(id_doc_in_trans), id_doc_out_trans = VALUES(id_doc_out_trans), id_branch = VALUES(id_branch), id_doc_status = VALUES(id_doc_status), id_stock_core = VALUES(id_stock_core), id_product = VALUES(id_product), id_supplier = VALUES(id_supplier), tmp_product_name = VALUES(tmp_product_name), engine_no = VALUES(engine_no), serial_no = VALUES(serial_no), is_volume_flag = VALUES(is_volume_flag), is_freebies_flag = VALUES(is_freebies_flag), qty_in_cost = VALUES(qty_in_cost), qty_in_free = VALUES(qty_in_free), qty_out_cost = VALUES(qty_out_cost), qty_out_free = VALUES(qty_out_free), price_per_unit = VALUES(price_per_unit), total_price = VALUES(total_price), down_payment = VALUES(down_payment), after_pay_down = VALUES(after_pay_down), net_price = VALUES(net_price), record_create_time = VALUES(record_create_time), record_create_by_id = VALUES(record_create_by_id), record_create_by_name = VALUES(record_create_by_name), record_update_time = VALUES(record_update_time), record_update_by_id = VALUES(record_update_by_id), record_update_by_name = VALUES(record_update_by_name), month_mm = VALUES(month_mm), year_20yy = VALUES(year_20yy), barcode = VALUES(barcode)`
	// run
	logf(sqlstr, st.IDStockTrans, st.IDDocInTrans, st.IDDocOutTrans, st.IDBranch, st.IDDocStatus, st.IDStockCore, st.IDProduct, st.IDSupplier, st.TmpProductName, st.EngineNo, st.SerialNo, st.IsVolumeFlag, st.IsFreebiesFlag, st.QtyInCost, st.QtyInFree, st.QtyOutCost, st.QtyOutFree, st.PricePerUnit, st.TotalPrice, st.DownPayment, st.AfterPayDown, st.NetPrice, st.RecordCreateTime, st.RecordCreateByID, st.RecordCreateByName, st.RecordUpdateTime, st.RecordUpdateByID, st.RecordUpdateByName, st.MonthMm, st.Year20yy, st.Barcode)
	if _, err := db.ExecContext(ctx, sqlstr, st.IDStockTrans, st.IDDocInTrans, st.IDDocOutTrans, st.IDBranch, st.IDDocStatus, st.IDStockCore, st.IDProduct, st.IDSupplier, st.TmpProductName, st.EngineNo, st.SerialNo, st.IsVolumeFlag, st.IsFreebiesFlag, st.QtyInCost, st.QtyInFree, st.QtyOutCost, st.QtyOutFree, st.PricePerUnit, st.TotalPrice, st.DownPayment, st.AfterPayDown, st.NetPrice, st.RecordCreateTime, st.RecordCreateByID, st.RecordCreateByName, st.RecordUpdateTime, st.RecordUpdateByID, st.RecordUpdateByName, st.MonthMm, st.Year20yy, st.Barcode); err != nil {
		return logerror(err)
	}
	// set exists
	st._exists = true
	return nil
}

// Delete deletes the StockTran from the database.
func (st *StockTran) Delete(ctx context.Context, db DB) error {
	switch {
	case !st._exists: // doesn't exist
		return nil
	case st._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM spc_holding.stock_trans ` +
		`WHERE id_stock_trans = ?`
	// run
	logf(sqlstr, st.IDStockTrans)
	if _, err := db.ExecContext(ctx, sqlstr, st.IDStockTrans); err != nil {
		return logerror(err)
	}
	// set deleted
	st._deleted = true
	return nil
}

// StockTranByIDStockTrans retrieves a row from 'spc_holding.stock_trans' as a StockTran.
//
// Generated from index 'stock_trans_id_stock_trans_pkey'.
func StockTranByIDStockTrans(ctx context.Context, db DB, idstockTrans uint) (*StockTran, error) {
	// query
	const sqlstr = `SELECT ` +
		`id_stock_trans, id_doc_in_trans, id_doc_out_trans, id_branch, id_doc_status, id_stock_core, id_product, id_supplier, tmp_product_name, engine_no, serial_no, is_volume_flag, is_freebies_flag, qty_in_cost, qty_in_free, qty_out_cost, qty_out_free, price_per_unit, total_price, down_payment, after_pay_down, net_price, record_create_time, record_create_by_id, record_create_by_name, record_update_time, record_update_by_id, record_update_by_name, month_mm, year_20yy, barcode ` +
		`FROM spc_holding.stock_trans ` +
		`WHERE id_stock_trans = ?`
	// run
	logf(sqlstr, idstockTrans)
	st := StockTran{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idstockTrans).Scan(&st.IDStockTrans, &st.IDDocInTrans, &st.IDDocOutTrans, &st.IDBranch, &st.IDDocStatus, &st.IDStockCore, &st.IDProduct, &st.IDSupplier, &st.TmpProductName, &st.EngineNo, &st.SerialNo, &st.IsVolumeFlag, &st.IsFreebiesFlag, &st.QtyInCost, &st.QtyInFree, &st.QtyOutCost, &st.QtyOutFree, &st.PricePerUnit, &st.TotalPrice, &st.DownPayment, &st.AfterPayDown, &st.NetPrice, &st.RecordCreateTime, &st.RecordCreateByID, &st.RecordCreateByName, &st.RecordUpdateTime, &st.RecordUpdateByID, &st.RecordUpdateByName, &st.MonthMm, &st.Year20yy, &st.Barcode); err != nil {
		return nil, logerror(err)
	}
	return &st, nil
}
