package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Supplier represents a row from 'spc_holding.supplier'.
type Supplier struct {
	IDSupplier         uint           `json:"id_supplier"`           // id_supplier
	SuppCode           sql.NullString `json:"supp_code"`             // supp_code
	SuppTaxID          sql.NullString `json:"supp_tax_id"`           // supp_tax_id
	SuppName           sql.NullString `json:"supp_name"`             // supp_name
	SuppAddress        sql.NullString `json:"supp_address"`          // supp_address
	IDAddrTambon       sql.NullInt64  `json:"id_addr_tambon"`        // id_addr_tambon
	TmpTambonName      sql.NullString `json:"tmp_tambon_name"`       // tmp_tambon_name
	IDAddrAmphure      sql.NullInt64  `json:"id_addr_amphure"`       // id_addr_amphure
	TmpAmphureName     sql.NullString `json:"tmp_amphure_name"`      // tmp_amphure_name
	IDAddrProvince     sql.NullInt64  `json:"id_addr_province"`      // id_addr_province
	TmpProvinceName    sql.NullString `json:"tmp_province_name"`     // tmp_province_name
	TmpZipCode         sql.NullString `json:"tmp_zip_code"`          // tmp_zip_code
	SuppTel            sql.NullString `json:"supp_tel"`              // supp_tel
	SuppEmail          sql.NullString `json:"supp_email"`            // supp_email
	SuppMobile         sql.NullString `json:"supp_mobile"`           // supp_mobile
	Contact1Name       sql.NullString `json:"contact1_name"`         // contact1_name
	Contact1Mobile     sql.NullString `json:"contact1_mobile"`       // contact1_mobile
	Contact1Email      sql.NullString `json:"contact1_email"`        // contact1_email
	Contact1Note       sql.NullString `json:"contact1_note"`         // contact1_note
	Contact2Name       sql.NullString `json:"contact2_name"`         // contact2_name
	Contact2Mobile     sql.NullString `json:"contact2_mobile"`       // contact2_mobile
	Contact2Email      sql.NullString `json:"contact2_email"`        // contact2_email
	Contact2Note       sql.NullString `json:"contact2_note"`         // contact2_note
	DueDate            sql.NullString `json:"due_date"`              // due_date
	AccNo              sql.NullString `json:"acc_no"`                // acc_no
	Bankname           sql.NullString `json:"bankname"`              // bankname
	RecordCreateTime   sql.NullInt64  `json:"record_create_time"`    // record_create_time
	RecordCreatByID    sql.NullInt64  `json:"record_creat_by_id"`    // record_creat_by_id
	RecordCreatByName  sql.NullString `json:"record_creat_by_name"`  // record_creat_by_name
	RecordUpdateTime   sql.NullInt64  `json:"record_update_time"`    // record_update_time
	RecordUpdateByID   sql.NullInt64  `json:"record_update_by_id"`   // record_update_by_id
	RecordUpdateByName sql.NullString `json:"record_update_by_name"` // record_update_by_name
	Note               sql.NullString `json:"note"`                  // note
	Status356Flag      sql.NullBool   `json:"status_356_flag"`       // status_356_flag
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the Supplier exists in the database.
func (s *Supplier) Exists() bool {
	return s._exists
}

// Deleted returns true when the Supplier has been marked for deletion from
// the database.
func (s *Supplier) Deleted() bool {
	return s._deleted
}

// Insert inserts the Supplier to the database.
func (s *Supplier) Insert(ctx context.Context, db DB) error {
	switch {
	case s._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case s._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO spc_holding.supplier (` +
		`supp_code, supp_tax_id, supp_name, supp_address, id_addr_tambon, tmp_tambon_name, id_addr_amphure, tmp_amphure_name, id_addr_province, tmp_province_name, tmp_zip_code, supp_tel, supp_email, supp_mobile, contact1_name, contact1_mobile, contact1_email, contact1_note, contact2_name, contact2_mobile, contact2_email, contact2_note, due_date, acc_no, bankname, record_create_time, record_creat_by_id, record_creat_by_name, record_update_time, record_update_by_id, record_update_by_name, note, status_356_flag` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, s.SuppCode, s.SuppTaxID, s.SuppName, s.SuppAddress, s.IDAddrTambon, s.TmpTambonName, s.IDAddrAmphure, s.TmpAmphureName, s.IDAddrProvince, s.TmpProvinceName, s.TmpZipCode, s.SuppTel, s.SuppEmail, s.SuppMobile, s.Contact1Name, s.Contact1Mobile, s.Contact1Email, s.Contact1Note, s.Contact2Name, s.Contact2Mobile, s.Contact2Email, s.Contact2Note, s.DueDate, s.AccNo, s.Bankname, s.RecordCreateTime, s.RecordCreatByID, s.RecordCreatByName, s.RecordUpdateTime, s.RecordUpdateByID, s.RecordUpdateByName, s.Note, s.Status356Flag)
	res, err := db.ExecContext(ctx, sqlstr, s.SuppCode, s.SuppTaxID, s.SuppName, s.SuppAddress, s.IDAddrTambon, s.TmpTambonName, s.IDAddrAmphure, s.TmpAmphureName, s.IDAddrProvince, s.TmpProvinceName, s.TmpZipCode, s.SuppTel, s.SuppEmail, s.SuppMobile, s.Contact1Name, s.Contact1Mobile, s.Contact1Email, s.Contact1Note, s.Contact2Name, s.Contact2Mobile, s.Contact2Email, s.Contact2Note, s.DueDate, s.AccNo, s.Bankname, s.RecordCreateTime, s.RecordCreatByID, s.RecordCreatByName, s.RecordUpdateTime, s.RecordUpdateByID, s.RecordUpdateByName, s.Note, s.Status356Flag)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	s.IDSupplier = uint(id)
	// set exists
	s._exists = true
	return nil
}

// Update updates a Supplier in the database.
func (s *Supplier) Update(ctx context.Context, db DB) error {
	switch {
	case !s._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case s._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE spc_holding.supplier SET ` +
		`supp_code = ?, supp_tax_id = ?, supp_name = ?, supp_address = ?, id_addr_tambon = ?, tmp_tambon_name = ?, id_addr_amphure = ?, tmp_amphure_name = ?, id_addr_province = ?, tmp_province_name = ?, tmp_zip_code = ?, supp_tel = ?, supp_email = ?, supp_mobile = ?, contact1_name = ?, contact1_mobile = ?, contact1_email = ?, contact1_note = ?, contact2_name = ?, contact2_mobile = ?, contact2_email = ?, contact2_note = ?, due_date = ?, acc_no = ?, bankname = ?, record_create_time = ?, record_creat_by_id = ?, record_creat_by_name = ?, record_update_time = ?, record_update_by_id = ?, record_update_by_name = ?, note = ?, status_356_flag = ? ` +
		`WHERE id_supplier = ?`
	// run
	logf(sqlstr, s.SuppCode, s.SuppTaxID, s.SuppName, s.SuppAddress, s.IDAddrTambon, s.TmpTambonName, s.IDAddrAmphure, s.TmpAmphureName, s.IDAddrProvince, s.TmpProvinceName, s.TmpZipCode, s.SuppTel, s.SuppEmail, s.SuppMobile, s.Contact1Name, s.Contact1Mobile, s.Contact1Email, s.Contact1Note, s.Contact2Name, s.Contact2Mobile, s.Contact2Email, s.Contact2Note, s.DueDate, s.AccNo, s.Bankname, s.RecordCreateTime, s.RecordCreatByID, s.RecordCreatByName, s.RecordUpdateTime, s.RecordUpdateByID, s.RecordUpdateByName, s.Note, s.Status356Flag, s.IDSupplier)
	if _, err := db.ExecContext(ctx, sqlstr, s.SuppCode, s.SuppTaxID, s.SuppName, s.SuppAddress, s.IDAddrTambon, s.TmpTambonName, s.IDAddrAmphure, s.TmpAmphureName, s.IDAddrProvince, s.TmpProvinceName, s.TmpZipCode, s.SuppTel, s.SuppEmail, s.SuppMobile, s.Contact1Name, s.Contact1Mobile, s.Contact1Email, s.Contact1Note, s.Contact2Name, s.Contact2Mobile, s.Contact2Email, s.Contact2Note, s.DueDate, s.AccNo, s.Bankname, s.RecordCreateTime, s.RecordCreatByID, s.RecordCreatByName, s.RecordUpdateTime, s.RecordUpdateByID, s.RecordUpdateByName, s.Note, s.Status356Flag, s.IDSupplier); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Supplier to the database.
func (s *Supplier) Save(ctx context.Context, db DB) error {
	if s.Exists() {
		return s.Update(ctx, db)
	}
	return s.Insert(ctx, db)
}

// Upsert performs an upsert for Supplier.
func (s *Supplier) Upsert(ctx context.Context, db DB) error {
	switch {
	case s._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO spc_holding.supplier (` +
		`id_supplier, supp_code, supp_tax_id, supp_name, supp_address, id_addr_tambon, tmp_tambon_name, id_addr_amphure, tmp_amphure_name, id_addr_province, tmp_province_name, tmp_zip_code, supp_tel, supp_email, supp_mobile, contact1_name, contact1_mobile, contact1_email, contact1_note, contact2_name, contact2_mobile, contact2_email, contact2_note, due_date, acc_no, bankname, record_create_time, record_creat_by_id, record_creat_by_name, record_update_time, record_update_by_id, record_update_by_name, note, status_356_flag` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`supp_code = VALUES(supp_code), supp_tax_id = VALUES(supp_tax_id), supp_name = VALUES(supp_name), supp_address = VALUES(supp_address), id_addr_tambon = VALUES(id_addr_tambon), tmp_tambon_name = VALUES(tmp_tambon_name), id_addr_amphure = VALUES(id_addr_amphure), tmp_amphure_name = VALUES(tmp_amphure_name), id_addr_province = VALUES(id_addr_province), tmp_province_name = VALUES(tmp_province_name), tmp_zip_code = VALUES(tmp_zip_code), supp_tel = VALUES(supp_tel), supp_email = VALUES(supp_email), supp_mobile = VALUES(supp_mobile), contact1_name = VALUES(contact1_name), contact1_mobile = VALUES(contact1_mobile), contact1_email = VALUES(contact1_email), contact1_note = VALUES(contact1_note), contact2_name = VALUES(contact2_name), contact2_mobile = VALUES(contact2_mobile), contact2_email = VALUES(contact2_email), contact2_note = VALUES(contact2_note), due_date = VALUES(due_date), acc_no = VALUES(acc_no), bankname = VALUES(bankname), record_create_time = VALUES(record_create_time), record_creat_by_id = VALUES(record_creat_by_id), record_creat_by_name = VALUES(record_creat_by_name), record_update_time = VALUES(record_update_time), record_update_by_id = VALUES(record_update_by_id), record_update_by_name = VALUES(record_update_by_name), note = VALUES(note), status_356_flag = VALUES(status_356_flag)`
	// run
	logf(sqlstr, s.IDSupplier, s.SuppCode, s.SuppTaxID, s.SuppName, s.SuppAddress, s.IDAddrTambon, s.TmpTambonName, s.IDAddrAmphure, s.TmpAmphureName, s.IDAddrProvince, s.TmpProvinceName, s.TmpZipCode, s.SuppTel, s.SuppEmail, s.SuppMobile, s.Contact1Name, s.Contact1Mobile, s.Contact1Email, s.Contact1Note, s.Contact2Name, s.Contact2Mobile, s.Contact2Email, s.Contact2Note, s.DueDate, s.AccNo, s.Bankname, s.RecordCreateTime, s.RecordCreatByID, s.RecordCreatByName, s.RecordUpdateTime, s.RecordUpdateByID, s.RecordUpdateByName, s.Note, s.Status356Flag)
	if _, err := db.ExecContext(ctx, sqlstr, s.IDSupplier, s.SuppCode, s.SuppTaxID, s.SuppName, s.SuppAddress, s.IDAddrTambon, s.TmpTambonName, s.IDAddrAmphure, s.TmpAmphureName, s.IDAddrProvince, s.TmpProvinceName, s.TmpZipCode, s.SuppTel, s.SuppEmail, s.SuppMobile, s.Contact1Name, s.Contact1Mobile, s.Contact1Email, s.Contact1Note, s.Contact2Name, s.Contact2Mobile, s.Contact2Email, s.Contact2Note, s.DueDate, s.AccNo, s.Bankname, s.RecordCreateTime, s.RecordCreatByID, s.RecordCreatByName, s.RecordUpdateTime, s.RecordUpdateByID, s.RecordUpdateByName, s.Note, s.Status356Flag); err != nil {
		return logerror(err)
	}
	// set exists
	s._exists = true
	return nil
}

// Delete deletes the Supplier from the database.
func (s *Supplier) Delete(ctx context.Context, db DB) error {
	switch {
	case !s._exists: // doesn't exist
		return nil
	case s._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM spc_holding.supplier ` +
		`WHERE id_supplier = ?`
	// run
	logf(sqlstr, s.IDSupplier)
	if _, err := db.ExecContext(ctx, sqlstr, s.IDSupplier); err != nil {
		return logerror(err)
	}
	// set deleted
	s._deleted = true
	return nil
}

// SupplierByIDSupplier retrieves a row from 'spc_holding.supplier' as a Supplier.
//
// Generated from index 'supplier_id_supplier_pkey'.
func SupplierByIDSupplier(ctx context.Context, db DB, idsupplier uint) (*Supplier, error) {
	// query
	const sqlstr = `SELECT ` +
		`id_supplier, supp_code, supp_tax_id, supp_name, supp_address, id_addr_tambon, tmp_tambon_name, id_addr_amphure, tmp_amphure_name, id_addr_province, tmp_province_name, tmp_zip_code, supp_tel, supp_email, supp_mobile, contact1_name, contact1_mobile, contact1_email, contact1_note, contact2_name, contact2_mobile, contact2_email, contact2_note, due_date, acc_no, bankname, record_create_time, record_creat_by_id, record_creat_by_name, record_update_time, record_update_by_id, record_update_by_name, note, status_356_flag ` +
		`FROM spc_holding.supplier ` +
		`WHERE id_supplier = ?`
	// run
	logf(sqlstr, idsupplier)
	s := Supplier{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, idsupplier).Scan(&s.IDSupplier, &s.SuppCode, &s.SuppTaxID, &s.SuppName, &s.SuppAddress, &s.IDAddrTambon, &s.TmpTambonName, &s.IDAddrAmphure, &s.TmpAmphureName, &s.IDAddrProvince, &s.TmpProvinceName, &s.TmpZipCode, &s.SuppTel, &s.SuppEmail, &s.SuppMobile, &s.Contact1Name, &s.Contact1Mobile, &s.Contact1Email, &s.Contact1Note, &s.Contact2Name, &s.Contact2Mobile, &s.Contact2Email, &s.Contact2Note, &s.DueDate, &s.AccNo, &s.Bankname, &s.RecordCreateTime, &s.RecordCreatByID, &s.RecordCreatByName, &s.RecordUpdateTime, &s.RecordUpdateByID, &s.RecordUpdateByName, &s.Note, &s.Status356Flag); err != nil {
		return nil, logerror(err)
	}
	return &s, nil
}
